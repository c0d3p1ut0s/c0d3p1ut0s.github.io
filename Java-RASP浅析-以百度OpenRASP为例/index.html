<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Java RASP浅析--以百度OpenRASP为例 | c0d3p1ut0s</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-111240445-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java RASP浅析--以百度OpenRASP为例</h1><a id="logo" href="/.">c0d3p1ut0s</a><p class="description">程序员 安全</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java RASP浅析--以百度OpenRASP为例</h1><div class="post-meta">Jan 25, 2018<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a data-disqus-identifier="Java-RASP浅析-以百度OpenRASP为例/" href="/Java-RASP浅析-以百度OpenRASP为例/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>RASP（Runtime Application self-protection）是一种在运行时检测攻击并且进行自我保护的一种技术。关于RASP技术和RASP实践，这是我写的第二篇文章，上一篇文章在<a href="https://c0d3p1ut0s.github.io/%E4%B8%80%E7%B1%BBPHP-RASP%E7%9A%84%E5%AE%9E%E7%8E%B0/">这里</a>，是关于RASP技术在PHP中的实践，无论是从设计思路还是技术实现来说，PHP RASP和OpenRASP Java实现都比较相似。有兴趣的同学可以粗略看看，不必太关心技术细节，了解设计思路、工作原理即可，很多时候，对技术宏观的把握对理解技术细节和设计思路非常有用。</p>
<h2 id="0x01-RASP技术"><a href="#0x01-RASP技术" class="headerlink" title="0x01 RASP技术"></a>0x01 RASP技术</h2><p>关于RASP的发展、RASP与各种WAF的区别以及RASP的简单原理可以看《<a href="https://c0d3p1ut0s.github.io/%E4%B8%80%E7%B1%BBPHP-RASP%E7%9A%84%E5%AE%9E%E7%8E%B0/">一类PHP RASP的实现</a>》这篇文章的<code>RASP概念</code>和<code>我的WAF世界观</code>这两部分，这两部分大约可以回答关于RASP技术的两个问题，一是RASP技术是工作在哪一层，为了解决什么问题而存在的，二是它大致是怎么实现的，这里就不写了。下面以OpenRASP为例分析一下Java RASP的实现。</p>
<h2 id="0x02-JVMTI-amp-amp-Java-Instrumentation"><a href="#0x02-JVMTI-amp-amp-Java-Instrumentation" class="headerlink" title="0x02 JVMTI &amp;&amp; Java Instrumentation"></a>0x02 JVMTI &amp;&amp; Java Instrumentation</h2><p>JVMTI是JVM提供的一些回调接口集。JVM在特定的状态会执行特定的回调函数，开发者实现这些回调函数就可以实现自己的逻辑。Java Instrumentation就是利用JVMTI实现的。</p>
<p>Java Instrumentation是Java强大功能的一个体现，Java Instrumentation允许开发者访问从JVM中加载的类，并且允许对它的字节码做修改，加入我们自己的代码，这些都是在运行时完成的。无需担心这个机制带来的安全问题，因为它也同样遵从适用于Java类和相应的类加载器的安全策略。</p>
<h2 id="0x03-OpenRASP简要分析"><a href="#0x03-OpenRASP简要分析" class="headerlink" title="0x03 OpenRASP简要分析"></a>0x03 OpenRASP简要分析</h2><p>OpenRASP以Java Instrumentation的方式工作在JVM层，它主要通过hook可能引发漏洞的关键函数，在这些关键函数执行之前添加安全检查，根据上下文和关键函数的参数等信息判断请求是否为恶意请求，并终止或继续执行流。</p>
<p>Java Instrumentation允许开发者添加自定义的字节码转换器来对Java字节码进行自定义的操作转化，从而实现在不修改源代码的情况下，实现AOP。当然，有一些开源的Java字节码类库帮助开发者操作Java字节码。OpenRASP的开发者选择了ASM这个框架，相比其他的框架，ASM的优点是更加底层、更加灵活，功能也更加丰富。</p>
<p>OpenRASP另一个值得称道的做法是使用了js来编写规则，通过Java语言实现的js引擎来执行脚本。OpenRASP官网关于为什么用JavaScript实现检测的逻辑的解释是 OpenRASP会支持PHP、DotNet、NodeJS、Python、Ruby等多种开发语言，为了避免在不同平台上重新实现检测逻辑，引入了插件系统; 选择JS作为插件开发语言。当然，这是优点之一。笔者认为，另一个优点是使用JS插件系统可以很方便的支持热部署。笔者曾经有幸参与某商业RASP产品的研发和测试，各语言规则的重复编写和热部署是两个令我们头痛的问题，而使用js引擎就可以很好的解决这两个问题。</p>
<h2 id="0x04-Talk-is-cheap"><a href="#0x04-Talk-is-cheap" class="headerlink" title="0x04 Talk is cheap"></a>0x04 Talk is cheap</h2><p>俗话说，Talk is cheap，show me the code. 下面简要分析一下OpenRASP的代码。OpenRASP是一个Java Instrumentation，它的入口是<code>public static void premain(String agentArg, Instrumentation inst)</code>函数，OpenRASP中的<code>premain</code>方法在<code>com.fuxi.javaagent.Agent</code>中。这个方法中主要的代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//........省略部分代码........</span></span><br><span class="line">JarFileHelper.addJarToBootstrap(inst);</span><br><span class="line"><span class="comment">//........省略部分代码........</span></span><br><span class="line">PluginManager.init();</span><br><span class="line">initTransformer(inst);</span><br><span class="line"><span class="comment">//........省略部分代码........</span></span><br></pre></td></tr></table></figure></p>
<p><code>JarFileHelper.addJarToBootstrap(inst)</code>的关键是JarFileHelper中<code>inst.appendToBootstrapClassLoaderSearch(new JarFile(localJarPath))</code>这行代码，它的作用是将rasp.jar加入到bootstrap classpath里，优先其他jar被加载。在Java Instrumention的实现中，这行代码应该是很常见的。为什么要这样做呢？在Java中，Java类加载器分为BootstrapClassLoader、ExtensionClassLoader和SystemClassLoader。BootstrapClassLoader主要加载的是JVM自身需要的类，由于双亲委派机制的存在，越基础的类由越上层的加载器进行加载，因此，如果需要在由BootstrapClassLoader加载的类的方法中调用由SystemClassLoader加载的rasp.jar，这违反了双亲委派机制。所以，而rasp.jar添加到BootstrapClassLoader的classpath中，由BootstrapClassLoader加载，就解决了这个问题。</p>
<p>接着是<code>PluginManager.init()</code>，初始化插件系统。<code>PluginManager.init()</code>的具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JSContextFactory.init();</span><br><span class="line">updatePlugin();</span><br><span class="line">initFileWatcher();</span><br></pre></td></tr></table></figure></p>
<p><code>JSContextFactory.init()</code>的主要作用是初始化js引擎，这里使用的js引擎是Mozilla的Rhino，Mozilla旗下提供了各种语言的js引擎的成熟实现，例如用C/C++实现的js引擎SpiderMonkey等。<code>JSContextFactory.init()</code>先初始化了js引擎，执行了一堆js文件，笔者js水平有限，就不分析了。接着把jsstdout注入到js环境中，处理js环境中的输出。把JSTokenizeSql和JSRASPConfig注入到RASP对象中，为js环境提供sql_tokenize方法，提供对SQL语句进行tokenize的能力。接下来<code>updatePlugin()</code>方法读取插件目录下的js文件，执行js脚本，加载插件。<code>initFileWatcher()</code>添加了文件监控，一旦插件目录下的js文件发送变化，则调用<code>updatePluginAsync()</code>执行clean方法，执行js脚本，更新插件，实现热部署功能。</p>
<p>接下来是<code>initTransformer(inst)</code>方法，它调用<code>inst.addTransformer(new CustomClassTransformer(), true)</code>方法添加了CustomClassTransformer这个Class转换器，这样，每一个类的字节码在加载之前都会调用<code>CustomClassTransformer.transform(..)</code>（参数省略）方法，对字节码进行更改之后，字节码被载入JVM中，接下来继续类加载过程：加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化。<code>CustomClassTransformer</code>类在初始化的时候创建了很多个ClassHook对象，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CustomClassTransformer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        hooks = <span class="keyword">new</span> HashSet&lt;AbstractClassHook&gt;();</span><br><span class="line"></span><br><span class="line">        addHook(<span class="keyword">new</span> WebDAVCopyResourceHook());</span><br><span class="line">        addHook(<span class="keyword">new</span> CoyoteInputStreamHook());</span><br><span class="line">        addHook(<span class="keyword">new</span> DeserializationHook());</span><br><span class="line">        addHook(<span class="keyword">new</span> DiskFileItemHook());</span><br><span class="line">        addHook(<span class="keyword">new</span> FileHook());</span><br><span class="line">        <span class="comment">//.....省略......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看一下<code>CustomClassTransformer.transform(..)</code>这个方法，如果当前加载的类是需要转换的，即<code>hook.isClassMatched(className)</code>返回true，就会调用<code>hook.transformClass(className, classfileBuffer)</code>对字节码进行转化。<code>transformClass</code>的代码在<code>com.fuxi.javaagent.hook.AbstractClassHook</code>中，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] transformClass(String className, <span class="keyword">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassReader reader = <span class="keyword">new</span> ClassReader(classfileBuffer);</span><br><span class="line">            ClassWriter writer = <span class="keyword">new</span> ClassWriter(reader, computeFrames() ? ClassWriter.COMPUTE_FRAMES : ClassWriter.COMPUTE_MAXS);</span><br><span class="line">            LOGGER.debug(<span class="string">"transform class: "</span> + className);</span><br><span class="line">            ClassVisitor visitor = <span class="keyword">new</span> RaspHookClassVisitor(<span class="keyword">this</span>, writer);</span><br><span class="line">            reader.accept(visitor, ClassReader.EXPAND_FRAMES);</span><br><span class="line">            <span class="keyword">return</span> writer.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码调用了ASM库，关于ASM库的详情请看<a href="http://web.cs.ucla.edu/~msb/cs239-tutorial/" target="_blank" rel="noopener">这里</a>，为了方便读者，笔者翻译了一下，在<a href="https://c0d3p1ut0s.github.io/%E8%AF%91-%E4%BD%BF%E7%94%A8ASM%E5%AF%B9Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%8F%92%E6%A1%A9/">这里</a>。如上文中所说，ASM是一个强大的字节码操作库。它主要使用了设计模式中的访问者模式，使用访问者模式的好处是数据结构与数据操作分开。在ASM中哪些是数据结构呢？转换前字节码中类、方法、注释、成员变量等就是数据结构，对这些字节码的操作就是数据操作。在ASM中，开发者不需要关心ASM解析字节码，遍历类、方法、注释等是怎样实现，只需要知道<code>ClassReader.accept()</code>接受一个ClassVisitor实例作为参数，在ASM遍历类、方法、注释时，ASM会调用<code>ClassVisitor.visitMethod()</code>、<code>ClassVisitor.visitAnnotation()</code>等方法。开发只需要重写这些方法，就可以操作方法、注释的字节码。如上面的代码所示，OpenRASP开发者创建了一个RaspHookClassVisitor类，重写了<code>visit</code>和<code>visitMethod</code>方法。在<code>visitMethod</code>方法中，ClassHook的<code>hookMethod</code>方法被调用，下面以FileHook为例，看一下<code>hookMethod</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">hookMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, String[] exceptions, MethodVisitor mv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"listFiles"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AdviceAdapter(Opcodes.ASM5, mv, access, name, desc) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMethodEnter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    loadThis();</span><br><span class="line">                    invokeStatic(Type.getType(HookHandler.class),</span><br><span class="line">                            <span class="keyword">new</span> Method(<span class="string">"checkListFiles"</span>, <span class="string">"(Ljava/io/File;)V"</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>invokeStatic(Type.getType(HookHandler.class),new Method(&quot;checkListFiles&quot;, &quot;(Ljava/io/File;)V&quot;)</code>这行代码调用了静态方法<code>HookHandler.checkListFiles</code>来实现对<code>java.io.File.listFiles</code>方法的检测。</p>
<p>各关键函数的检测有些区别，我就不分析了，很多都是最后调用<code>com.fuxi.javaagent.plugin.check</code>进行检测，而<code>com.fuxi.javaagent.plugin.check</code>最后调用了各js函数来检测。代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">checkProcess = processList.get(i);</span><br><span class="line">function = checkProcess.getFunction();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    tmp = function.call(<span class="keyword">this</span>, scope, function, functionArgs);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//......省略......</span></span><br></pre></td></tr></table></figure></p>
<p>对检测细节感兴趣的可以一个一个跟。</p>
<h2 id="0x05-关于OpenRASP规则的几点说明"><a href="#0x05-关于OpenRASP规则的几点说明" class="headerlink" title="0x05 关于OpenRASP规则的几点说明"></a>0x05 关于OpenRASP规则的几点说明</h2><p>OpenRASP提供了一些官方插件，当然，相关的规则还是需要根据业务和开发水平来定制。开发者水平参差不齐，什么奇葩的实现方式都有。例如，笔者之前参与研发的RASP也有这么一条规则：禁止在SQL语句中出现常量比较操作。但是，这条规则在实际中却有不少误报。很多开发会这样写(用伪代码表示一下)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String sql=<span class="string">"select * from table where 1=1"</span>;</span><br><span class="line"><span class="keyword">for</span>(key,value in condition.items())&#123;</span><br><span class="line">    sql+=<span class="string">" and "</span>+key+<span class="string">"="</span>+<span class="string">"value"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>开发会自己添加1=1，为了能方便的在循环中在SQL后面的where语句中直接加and，而1=1永远为真，不影响后面的逻辑。所以说，规则永远是和场景分不开的，同样，不深入开发、不深入客户很难做好安全产品。说白了，做安全，开发安全产品和软件工程的目标是一致的，即让大多数的Stakeholder(利益相关者)满意。开发当然也是RASP产品的Stakeholder。好了，扯远了。</p>
<p>OpenRASP中对SQL做了词法分析来实现”零规则”检测。实际上，词法分析的主要作用是将SQL语句分割成数据和代码。SQL注入的本质是代码注入，有了词法分析的帮助，Web层就可以判断对SQL语句的字符串处理是否改变了SQL的逻辑。这是词法分析为什么可以用来检测SQL注入的原因，类似的，利用词法分析也可以检测其他代码注入。不过把SQL的词法分析做好并不容易，一个原因是SQL语句语法复杂，不同的数据库有不同的语法，不同的数据库还有不同的奇葩特性。从代码来看OpenRASP的词法分析暂时还没有区分不同的数据库。</p>
<p>RASP并不能高效地防御所有的漏洞，还是那句话，Web服务器、解释器/JVM、数据库、操作系统各有各的防御阵地，各有各的优势，充分发挥它们的优势，才能更好的做好安全防护。希望这篇文章能对想用RASP产品或者想研发RASP的公司有一些帮助。</p>
<h2 id="0x06-Reference"><a href="#0x06-Reference" class="headerlink" title="0x06 Reference"></a>0x06 Reference</h2><ul>
<li><a href="https://rasp.baidu.com/" target="_blank" rel="noopener">OpenRASP官网</a></li>
<li><a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a></li>
<li><a href="http://blog.nsfocus.net/openrasp-tech/" target="_blank" rel="noopener">绿盟博客</a></li>
</ul>
<h2 id="0x07-关于作者"><a href="#0x07-关于作者" class="headerlink" title="0x07 关于作者"></a>0x07 关于作者</h2><ul>
<li><a href="https://c0d3p1ut0s.github.io/">我的博客</a></li>
<li>c0d3p1ut0s c0d3p1ut0s@gmail.com</li>
</ul>
</div><div class="tags"><a href="/tags/Web安全/">Web安全</a><a href="/tags/Java安全/">Java安全</a><a href="/tags/Java/">Java</a><a href="/tags/RASP/">RASP</a></div><div class="post-nav"><a href="/译-使用ASM对Java字节码插桩/" class="next">[译]使用ASM对Java字节码插桩</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'c0d3p1ut0s';
var disqus_identifier = 'Java-RASP浅析-以百度OpenRASP为例/';
var disqus_title = 'Java RASP浅析--以百度OpenRASP为例';
var disqus_url = 'http://c0d3p1ut0s.github.io/Java-RASP浅析-以百度OpenRASP为例/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//c0d3p1ut0s.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://c0d3p1ut0s.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Web安全/" style="font-size: 15px;">Web安全</a> <a href="/tags/Java安全/" style="font-size: 15px;">Java安全</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/RASP/" style="font-size: 15px;">RASP</a> <a href="/tags/aboutme/" style="font-size: 15px;">aboutme</a> <a href="/tags/PHP/" style="font-size: 15px;">PHP</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/Java字节码/" style="font-size: 15px;">Java字节码</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/Java-RASP浅析-以百度OpenRASP为例/">Java RASP浅析--以百度OpenRASP为例</a></li><li class="post-list-item"><a class="post-list-link" href="/译-使用ASM对Java字节码插桩/">[译]使用ASM对Java字节码插桩</a></li><li class="post-list-item"><a class="post-list-link" href="/BurpUnlimited分析/">BurpUnlimited分析</a></li><li class="post-list-item"><a class="post-list-link" href="/一类PHP-RASP的实现/">一类PHP RASP的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/about/">About</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//c0d3p1ut0s.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.nudtcat.org" title="s1m0n的博客" target="_blank">s1m0n的博客</a><ul></ul><a href="http://www.yinwang.org/" title="当然我在扯淡" target="_blank">当然我在扯淡</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">c0d3p1ut0s.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>