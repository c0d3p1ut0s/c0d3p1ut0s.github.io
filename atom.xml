<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>c0d3p1ut0s</title>
  
  <subtitle>程序员 安全</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://c0d3p1ut0s.github.io/"/>
  <updated>2018-03-21T11:10:04.000Z</updated>
  <id>http://c0d3p1ut0s.github.io/</id>
  
  <author>
    <name>c0d3p1ut0s</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简单说说MySQL Prepared Statement</title>
    <link href="http://c0d3p1ut0s.github.io/%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4MySQL-Prepared-Statement/"/>
    <id>http://c0d3p1ut0s.github.io/简单说说MySQL-Prepared-Statement/</id>
    <published>2018-03-21T11:05:36.000Z</published>
    <updated>2018-03-21T11:10:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>之前在写安全测试报告时，对于SQL注入的修复建议或者防御措施无非是两条：一是白名单限制，二是参数化查询。对于参数化查询的原理，停留于MySQL能先将SQL语句进行词法和语法解析，再将参数绑定执行的阶段。而我们在代码中用Prepared Statement语句实现参数化查询时，很可能事实并不是如此。</p><h2 id="0x01-问题"><a href="#0x01-问题" class="headerlink" title="0x01 问题"></a>0x01 问题</h2><p>网上关于预编译语句的文章有很多，但是，大部分都是基于片面的实验得到以偏概全的结论。争论最多的问题是一般情况下MySQL是否开启了服务端的预编译。网上众说纷纭，经过实验，我得出来的结论是MySQL是否开启服务端的预编译是由客户端连接时的参数useServerPrepStmts决定的，而在MySQL提供的Connector/J版本5.0.5（release 2007-03-02）之后，默认情况下，useServerPrepStmts=false。即如果没有显式设置成true，默认情况下，MySQL不启用服务端预编译。</p><p>那么我们在代码中使用预编译函数，例如Java中的prepareStatement，是否存在SQL注入的风险呢？</p><h2 id="0x02-实验"><a href="#0x02-实验" class="headerlink" title="0x02 实验"></a>0x02 实验</h2><p>实验之前先打开MySQL服务器的日志，在my.ini中加一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log=&quot;D:/mysql.log&quot;</span><br></pre></td></tr></table></figure></p><p>为了方便查看与MySQL服务器的通信，实验中使用了wireshark，如果MySQL服务器在本地，wireshark可能抓不到包，可以用本地ip连接MySQL服务器，不使用127.0.0.1或者localhost。并以管理员身份运行cmd，运行以下命令添加路由<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add 本地ip mask 255.255.255.255 本地网关</span><br></pre></td></tr></table></figure></p><p>MySQL官网在Connector/J 5.0.5的变更中有如下内容</p><blockquote><p>Important change: Due to a number of issues with the use of server-side prepared statements, Connector/J 5.0.5 has disabled their use by default. The disabling of server-side prepared statements does not affect the operation of the connector in any way.</p><p>To enable server-side prepared statements, add the following configuration property to your connector string:</p><p>useServerPrepStmts=true</p><p>The default value of this property is false (that is, Connector/J does not use server-side prepared statements).</p></blockquote><p>大致意思是Connector/J 5.05及以后的版本中，默认情况下useServerPrepStmts的值是false，不使用服务端预编译。这里，我用的Connector/J版本是5.1.46。</p><p>首先，我们看一下useServerPrepStmts=true情况下wireshark的抓包和MySQL的日志。代码如下：<br><img src="https://i.loli.net/2018/03/21/5ab1fb5d38555.png" alt="201803211422.PNG"></p><p>运行代码，抓包如下：<br><img src="https://i.loli.net/2018/03/21/5ab1fb5d2f323.png" alt="201803211425.png"><br>上面这个包是发送给要求MySQL服务器Prepare语句”select * from user where id=?”<br><img src="https://i.loli.net/2018/03/21/5ab1fb5d2ddc8.png" alt="201803211426.png"><br>接下来发送填充到占位符的字符串的值，我们看到，在这里字符串没有被转义。<br><img src="https://i.loli.net/2018/03/21/5ab1fb5d36e47.png" alt="201803211427.png"><br>这是MySQL的日志，可以明显看到，MySQL prepare了语句select * from user WHERE id=?，接着执行了select * from user WHERE id=’1\‘ or \‘1\‘=\‘1’。</p><p>很明显，MySQL服务器对SQL语句做了预编译。</p><p>接着，去掉useServerPrepStmts=true，在普通情况下会发生什么呢？<br>代码如下：<br><img src="https://i.loli.net/2018/03/21/5ab1fe3048921.png" alt="201803211434.png"><br><img src="https://i.loli.net/2018/03/21/5ab1fe3047411.png" alt="201803211435.png"></p><p>抓包发现，java程序仅向MySQL服务器发送了一个Query请求，而且Query的SQL语句是select * from user WHERE id=’1\‘ or \‘1\‘=\‘1’。</p><p><img src="https://i.loli.net/2018/03/21/5ab1fe3049f76.png" alt="201803211437.png"><br>从MySQL日志中，我们发现也确实如此。这是为什么呢？</p><h2 id="0x03-客户端预编译"><a href="#0x03-客户端预编译" class="headerlink" title="0x03 客户端预编译"></a>0x03 客户端预编译</h2><p>我们跟一下<code>PreparedStatement statement = connection.prepareStatement(sql)</code>这一句，F7跟进，在com.mysql.jdbc.ConnectionImpl中存在以下逻辑：<br>2792行：<br><img src="https://i.loli.net/2018/03/21/5ab20549327d3.png" alt="201803211502.png"></p><p>判断了一下useServerPreparedStmts是否打开和canServerPrepare是否为true，均为true则走下面调用服务端预编译的逻辑。而默认情况下，useServerPreparedStmts=false，因此，代码到2837行：<br><img src="https://i.loli.net/2018/03/21/5ab2054882f15.png" alt="201803211503.png"><br>调用clientPrepareStatement来对SQL语句进行处理。这样的话，对单引号等关键字符的转义在哪里做的呢？</p><p>我们接着来跟一下<code>statement.setString(1, &quot;1&#39; or &#39;1&#39;=&#39;1&quot;);</code>这一句。在com.mysql.jdbc.PreparedStatement中，2238行开始<br><img src="https://i.loli.net/2018/03/21/5ab20a62051dc.png" alt="201803211520.png"><br>省略部分代码<br><img src="https://i.loli.net/2018/03/21/5ab20a62526a1.png" alt="201803211529.png"><br>从2282行开始，对填充的字符串做转义处理，并在转义之后的字符串前后填加单引号。这段代码的主要作用是转义字符串，防止SQL注入。</p><h2 id="0x04-试着突破它"><a href="#0x04-试着突破它" class="headerlink" title="0x04 试着突破它"></a>0x04 试着突破它</h2><p>这里转义的字符比较少，有没有漏掉一些字符，能够逃逸出单引号呢？我对SQL注入并不精通，凭空想出一些payload比较难，这里有两种方法可以试一下，一是参看类似的实现，例如php中addslashes的源代码，二是fuzz。</p><p>PHP的addslashes的源代码在ext/standard/string.c中。遗憾的是，并没有发现其他字符。</p><p>接下来是fuzz，Java中，字符的编码是utf16，Unicode的编码空间从U+0000到U+10FFFF，共有1,112,064个码位。进过fuzz测试，也没有发现能逃逸单引号的字符。</p><h2 id="0x05-其他语言的客户端prepare"><a href="#0x05-其他语言的客户端prepare" class="headerlink" title="0x05 其他语言的客户端prepare"></a>0x05 其他语言的客户端prepare</h2><p>MySQL官方提供了各种语言连接MySQL的Connectors，其他语言的connectors是不是也默认客户端prepare呢？我测试了Python的，结果也是同样。其余Connectors有兴趣的读者可以自行测试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;之前在写安全测试报告时，对于SQL注入的修复建议或者防御措施无非是两条：一是白名单限制，二是参数化查
      
    
    </summary>
    
    
      <category term="Java安全" scheme="http://c0d3p1ut0s.github.io/tags/Java%E5%AE%89%E5%85%A8/"/>
    
      <category term="MySQL" scheme="http://c0d3p1ut0s.github.io/tags/MySQL/"/>
    
      <category term="SQL注入" scheme="http://c0d3p1ut0s.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java RASP浅析--以百度OpenRASP为例</title>
    <link href="http://c0d3p1ut0s.github.io/Java-RASP%E6%B5%85%E6%9E%90-%E4%BB%A5%E7%99%BE%E5%BA%A6OpenRASP%E4%B8%BA%E4%BE%8B/"/>
    <id>http://c0d3p1ut0s.github.io/Java-RASP浅析-以百度OpenRASP为例/</id>
    <published>2018-01-25T11:01:30.000Z</published>
    <updated>2018-01-25T11:02:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>RASP（Runtime Application self-protection）是一种在运行时检测攻击并且进行自我保护的一种技术。关于RASP技术和RASP实践，这是我写的第二篇文章，上一篇文章在<a href="https://c0d3p1ut0s.github.io/%E4%B8%80%E7%B1%BBPHP-RASP%E7%9A%84%E5%AE%9E%E7%8E%B0/">这里</a>，是关于RASP技术在PHP中的实践，无论是从设计思路还是技术实现来说，PHP RASP和OpenRASP Java实现都比较相似。有兴趣的同学可以粗略看看，不必太关心技术细节，了解设计思路、工作原理即可，很多时候，对技术宏观的把握对理解技术细节和设计思路非常有用。</p><h2 id="0x01-RASP技术"><a href="#0x01-RASP技术" class="headerlink" title="0x01 RASP技术"></a>0x01 RASP技术</h2><p>关于RASP的发展、RASP与各种WAF的区别以及RASP的简单原理可以看《<a href="https://c0d3p1ut0s.github.io/%E4%B8%80%E7%B1%BBPHP-RASP%E7%9A%84%E5%AE%9E%E7%8E%B0/">一类PHP RASP的实现</a>》这篇文章的<code>RASP概念</code>和<code>我的WAF世界观</code>这两部分，这两部分大约可以回答关于RASP技术的两个问题，一是RASP技术是工作在哪一层，为了解决什么问题而存在的，二是它大致是怎么实现的，这里就不写了。下面以OpenRASP为例分析一下Java RASP的实现。</p><h2 id="0x02-JVMTI-amp-amp-Java-Instrumentation"><a href="#0x02-JVMTI-amp-amp-Java-Instrumentation" class="headerlink" title="0x02 JVMTI &amp;&amp; Java Instrumentation"></a>0x02 JVMTI &amp;&amp; Java Instrumentation</h2><p>JVMTI是JVM提供的一些回调接口集。JVM在特定的状态会执行特定的回调函数，开发者实现这些回调函数就可以实现自己的逻辑。Java Instrumentation就是利用JVMTI实现的。</p><p>Java Instrumentation是Java强大功能的一个体现，Java Instrumentation允许开发者访问从JVM中加载的类，并且允许对它的字节码做修改，加入我们自己的代码，这些都是在运行时完成的。无需担心这个机制带来的安全问题，因为它也同样遵从适用于Java类和相应的类加载器的安全策略。</p><h2 id="0x03-OpenRASP简要分析"><a href="#0x03-OpenRASP简要分析" class="headerlink" title="0x03 OpenRASP简要分析"></a>0x03 OpenRASP简要分析</h2><p>OpenRASP以Java Instrumentation的方式工作在JVM层，它主要通过hook可能引发漏洞的关键函数，在这些关键函数执行之前添加安全检查，根据上下文和关键函数的参数等信息判断请求是否为恶意请求，并终止或继续执行流。</p><p>Java Instrumentation允许开发者添加自定义的字节码转换器来对Java字节码进行自定义的操作转化，从而实现在不修改源代码的情况下，实现AOP。当然，有一些开源的Java字节码类库帮助开发者操作Java字节码。OpenRASP的开发者选择了ASM这个框架，相比其他的框架，ASM的优点是更加底层、更加灵活，功能也更加丰富。</p><p>OpenRASP另一个值得称道的做法是使用了js来编写规则，通过Java语言实现的js引擎来执行脚本。OpenRASP官网关于为什么用JavaScript实现检测的逻辑的解释是 OpenRASP会支持PHP、DotNet、NodeJS、Python、Ruby等多种开发语言，为了避免在不同平台上重新实现检测逻辑，引入了插件系统; 选择JS作为插件开发语言。当然，这是优点之一。笔者认为，另一个优点是使用JS插件系统可以很方便的支持热部署。笔者曾经有幸参与某商业RASP产品的研发和测试，各语言规则的重复编写和热部署是两个令我们头痛的问题，而使用js引擎就可以很好的解决这两个问题。</p><h2 id="0x04-Talk-is-cheap"><a href="#0x04-Talk-is-cheap" class="headerlink" title="0x04 Talk is cheap"></a>0x04 Talk is cheap</h2><p>俗话说，Talk is cheap，show me the code. 下面简要分析一下OpenRASP的代码。OpenRASP是一个Java Instrumentation，它的入口是<code>public static void premain(String agentArg, Instrumentation inst)</code>函数，OpenRASP中的<code>premain</code>方法在<code>com.fuxi.javaagent.Agent</code>中。这个方法中主要的代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//........省略部分代码........</span></span><br><span class="line">JarFileHelper.addJarToBootstrap(inst);</span><br><span class="line"><span class="comment">//........省略部分代码........</span></span><br><span class="line">PluginManager.init();</span><br><span class="line">initTransformer(inst);</span><br><span class="line"><span class="comment">//........省略部分代码........</span></span><br></pre></td></tr></table></figure></p><p><code>JarFileHelper.addJarToBootstrap(inst)</code>的关键是JarFileHelper中<code>inst.appendToBootstrapClassLoaderSearch(new JarFile(localJarPath))</code>这行代码，它的作用是将rasp.jar加入到bootstrap classpath里，优先其他jar被加载。在Java Instrumention的实现中，这行代码应该是很常见的。为什么要这样做呢？在Java中，Java类加载器分为BootstrapClassLoader、ExtensionClassLoader和SystemClassLoader。BootstrapClassLoader主要加载的是JVM自身需要的类，由于双亲委派机制的存在，越基础的类由越上层的加载器进行加载，因此，如果需要在由BootstrapClassLoader加载的类的方法中调用由SystemClassLoader加载的rasp.jar，这违反了双亲委派机制。所以，而rasp.jar添加到BootstrapClassLoader的classpath中，由BootstrapClassLoader加载，就解决了这个问题。</p><p>接着是<code>PluginManager.init()</code>，初始化插件系统。<code>PluginManager.init()</code>的具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JSContextFactory.init();</span><br><span class="line">updatePlugin();</span><br><span class="line">initFileWatcher();</span><br></pre></td></tr></table></figure></p><p><code>JSContextFactory.init()</code>的主要作用是初始化js引擎，这里使用的js引擎是Mozilla的Rhino，Mozilla旗下提供了各种语言的js引擎的成熟实现，例如用C/C++实现的js引擎SpiderMonkey等。<code>JSContextFactory.init()</code>先初始化了js引擎，执行了一堆js文件，笔者js水平有限，就不分析了。接着把jsstdout注入到js环境中，处理js环境中的输出。把JSTokenizeSql和JSRASPConfig注入到RASP对象中，为js环境提供sql_tokenize方法，提供对SQL语句进行tokenize的能力。接下来<code>updatePlugin()</code>方法读取插件目录下的js文件，执行js脚本，加载插件。<code>initFileWatcher()</code>添加了文件监控，一旦插件目录下的js文件发送变化，则调用<code>updatePluginAsync()</code>执行clean方法，执行js脚本，更新插件，实现热部署功能。</p><p>接下来是<code>initTransformer(inst)</code>方法，它调用<code>inst.addTransformer(new CustomClassTransformer(), true)</code>方法添加了CustomClassTransformer这个Class转换器，这样，每一个类的字节码在加载之前都会调用<code>CustomClassTransformer.transform(..)</code>（参数省略）方法，对字节码进行更改之后，字节码被载入JVM中，接下来继续类加载过程：加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化。<code>CustomClassTransformer</code>类在初始化的时候创建了很多个ClassHook对象，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CustomClassTransformer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        hooks = <span class="keyword">new</span> HashSet&lt;AbstractClassHook&gt;();</span><br><span class="line"></span><br><span class="line">        addHook(<span class="keyword">new</span> WebDAVCopyResourceHook());</span><br><span class="line">        addHook(<span class="keyword">new</span> CoyoteInputStreamHook());</span><br><span class="line">        addHook(<span class="keyword">new</span> DeserializationHook());</span><br><span class="line">        addHook(<span class="keyword">new</span> DiskFileItemHook());</span><br><span class="line">        addHook(<span class="keyword">new</span> FileHook());</span><br><span class="line">        <span class="comment">//.....省略......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们看一下<code>CustomClassTransformer.transform(..)</code>这个方法，如果当前加载的类是需要转换的，即<code>hook.isClassMatched(className)</code>返回true，就会调用<code>hook.transformClass(className, classfileBuffer)</code>对字节码进行转化。<code>transformClass</code>的代码在<code>com.fuxi.javaagent.hook.AbstractClassHook</code>中，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] transformClass(String className, <span class="keyword">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassReader reader = <span class="keyword">new</span> ClassReader(classfileBuffer);</span><br><span class="line">            ClassWriter writer = <span class="keyword">new</span> ClassWriter(reader, computeFrames() ? ClassWriter.COMPUTE_FRAMES : ClassWriter.COMPUTE_MAXS);</span><br><span class="line">            LOGGER.debug(<span class="string">"transform class: "</span> + className);</span><br><span class="line">            ClassVisitor visitor = <span class="keyword">new</span> RaspHookClassVisitor(<span class="keyword">this</span>, writer);</span><br><span class="line">            reader.accept(visitor, ClassReader.EXPAND_FRAMES);</span><br><span class="line">            <span class="keyword">return</span> writer.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这段代码调用了ASM库，关于ASM库的详情请看<a href="http://web.cs.ucla.edu/~msb/cs239-tutorial/" target="_blank" rel="noopener">这里</a>，为了方便读者，笔者翻译了一下，在<a href="https://c0d3p1ut0s.github.io/%E8%AF%91-%E4%BD%BF%E7%94%A8ASM%E5%AF%B9Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%8F%92%E6%A1%A9/">这里</a>。如上文中所说，ASM是一个强大的字节码操作库。它主要使用了设计模式中的访问者模式，使用访问者模式的好处是数据结构与数据操作分开。在ASM中哪些是数据结构呢？转换前字节码中类、方法、注释、成员变量等就是数据结构，对这些字节码的操作就是数据操作。在ASM中，开发者不需要关心ASM解析字节码，遍历类、方法、注释等是怎样实现，只需要知道<code>ClassReader.accept()</code>接受一个ClassVisitor实例作为参数，在ASM遍历类、方法、注释时，ASM会调用<code>ClassVisitor.visitMethod()</code>、<code>ClassVisitor.visitAnnotation()</code>等方法。开发只需要重写这些方法，就可以操作方法、注释的字节码。如上面的代码所示，OpenRASP开发者创建了一个RaspHookClassVisitor类，重写了<code>visit</code>和<code>visitMethod</code>方法。在<code>visitMethod</code>方法中，ClassHook的<code>hookMethod</code>方法被调用，下面以FileHook为例，看一下<code>hookMethod</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">hookMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, String[] exceptions, MethodVisitor mv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"listFiles"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AdviceAdapter(Opcodes.ASM5, mv, access, name, desc) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMethodEnter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    loadThis();</span><br><span class="line">                    invokeStatic(Type.getType(HookHandler.class),</span><br><span class="line">                            <span class="keyword">new</span> Method(<span class="string">"checkListFiles"</span>, <span class="string">"(Ljava/io/File;)V"</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>invokeStatic(Type.getType(HookHandler.class),new Method(&quot;checkListFiles&quot;, &quot;(Ljava/io/File;)V&quot;)</code>这行代码调用了静态方法<code>HookHandler.checkListFiles</code>来实现对<code>java.io.File.listFiles</code>方法的检测。</p><p>各关键函数的检测有些区别，我就不分析了，很多都是最后调用<code>com.fuxi.javaagent.plugin.check</code>进行检测，而<code>com.fuxi.javaagent.plugin.check</code>最后调用了各js函数来检测。代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">checkProcess = processList.get(i);</span><br><span class="line">function = checkProcess.getFunction();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    tmp = function.call(<span class="keyword">this</span>, scope, function, functionArgs);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//......省略......</span></span><br></pre></td></tr></table></figure></p><p>对检测细节感兴趣的可以一个一个跟。</p><h2 id="0x05-关于OpenRASP规则的几点说明"><a href="#0x05-关于OpenRASP规则的几点说明" class="headerlink" title="0x05 关于OpenRASP规则的几点说明"></a>0x05 关于OpenRASP规则的几点说明</h2><p>OpenRASP提供了一些官方插件，当然，相关的规则还是需要根据业务和开发水平来定制。开发者水平参差不齐，什么奇葩的实现方式都有。例如，笔者之前参与研发的RASP也有这么一条规则：禁止在SQL语句中出现常量比较操作。但是，这条规则在实际中却有不少误报。很多开发会这样写(用伪代码表示一下)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String sql=<span class="string">"select * from table where 1=1"</span>;</span><br><span class="line"><span class="keyword">for</span>(key,value in condition.items())&#123;</span><br><span class="line">    sql+=<span class="string">" and "</span>+key+<span class="string">"="</span>+<span class="string">"value"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>开发会自己添加1=1，为了能方便的在循环中在SQL后面的where语句中直接加and，而1=1永远为真，不影响后面的逻辑。所以说，规则永远是和场景分不开的，同样，不深入开发、不深入客户很难做好安全产品。说白了，做安全，开发安全产品和软件工程的目标是一致的，即让大多数的Stakeholder(利益相关者)满意。开发当然也是RASP产品的Stakeholder。好了，扯远了。</p><p>OpenRASP中对SQL做了词法分析来实现”零规则”检测。实际上，词法分析的主要作用是将SQL语句分割成数据和代码。SQL注入的本质是代码注入，有了词法分析的帮助，Web层就可以判断对SQL语句的字符串处理是否改变了SQL的逻辑。这是词法分析为什么可以用来检测SQL注入的原因，类似的，利用词法分析也可以检测其他代码注入。不过把SQL的词法分析做好并不容易，一个原因是SQL语句语法复杂，不同的数据库有不同的语法，不同的数据库还有不同的奇葩特性。从代码来看OpenRASP的词法分析暂时还没有区分不同的数据库。</p><p>RASP并不能高效地防御所有的漏洞，还是那句话，Web服务器、解释器/JVM、数据库、操作系统各有各的防御阵地，各有各的优势，充分发挥它们的优势，才能更好的做好安全防护。希望这篇文章能对想用RASP产品或者想研发RASP的公司有一些帮助。</p><h2 id="0x06-Reference"><a href="#0x06-Reference" class="headerlink" title="0x06 Reference"></a>0x06 Reference</h2><ul><li><a href="https://rasp.baidu.com/" target="_blank" rel="noopener">OpenRASP官网</a></li><li><a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a></li><li><a href="http://blog.nsfocus.net/openrasp-tech/" target="_blank" rel="noopener">绿盟博客</a></li></ul><h2 id="0x07-关于作者"><a href="#0x07-关于作者" class="headerlink" title="0x07 关于作者"></a>0x07 关于作者</h2><ul><li><a href="https://c0d3p1ut0s.github.io/">我的博客</a></li><li>c0d3p1ut0s c0d3p1ut0s@gmail.com</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;RASP（Runtime Application self-protection）是一种在运行时检测
      
    
    </summary>
    
    
      <category term="Web安全" scheme="http://c0d3p1ut0s.github.io/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java安全" scheme="http://c0d3p1ut0s.github.io/tags/Java%E5%AE%89%E5%85%A8/"/>
    
      <category term="RASP" scheme="http://c0d3p1ut0s.github.io/tags/RASP/"/>
    
      <category term="Java" scheme="http://c0d3p1ut0s.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[译]使用ASM对Java字节码插桩</title>
    <link href="http://c0d3p1ut0s.github.io/%E8%AF%91-%E4%BD%BF%E7%94%A8ASM%E5%AF%B9Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%8F%92%E6%A1%A9/"/>
    <id>http://c0d3p1ut0s.github.io/译-使用ASM对Java字节码插桩/</id>
    <published>2017-12-27T14:19:23.000Z</published>
    <updated>2017-12-27T15:02:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译自 <a href="http://web.cs.ucla.edu/~msb/cs239-tutorial/" target="_blank" rel="noopener">http://web.cs.ucla.edu/~msb/cs239-tutorial/</a></p></blockquote><p>在这篇文章中，你将学会如何使用ASM框架对java class文件插桩。文章第一部分介绍Java字节码以及如何阅读class文件。第二部分介绍贯穿ASM框架的vistor模式。第三部分我们将用ASM构建一个简单的调用链跟踪插桩。</p><a id="more"></a><h2 id="第一部分：Java字节码"><a href="#第一部分：Java字节码" class="headerlink" title="第一部分：Java字节码"></a>第一部分：Java字节码</h2><p>ASM是一个Java字节码操作框架，首先介绍一下Java字节码。Java字节码是Java虚拟机（JVM）的指令集。每一条指令由一个字节的操作码和0个或者多个操作数组成。例如”iadd”,它接收两个整数作为操作数。你可以在<a href="https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings" target="_blank" rel="noopener">这里</a>查看操作指令和操作数的细节。下面有一个简单的列表帮助我们更好地了解java字节码：</p><ul><li>加载和存储（例如：aload_0, istore）</li><li>数学和逻辑运算（例如：ladd, fcmpl）</li><li>类型转换（例如：i2b, d2i）</li><li>对象创建和操作（例如：new, putfield）</li><li>操作数栈管理（例如：swap, dup2）</li><li>控制转移（例如：ifeq, goto）</li><li>方法调用和返回（例如：invokespecial, areturn）</li></ul><h3 id="Java虚拟机："><a href="#Java虚拟机：" class="headerlink" title="Java虚拟机："></a>Java虚拟机：</h3><p>要理解java字节码的细节，我们需要了解JVM如何执行字节码。JVM是一个与平台无关的执行环境，它将java字节码转换为机器语言，然后执行。JVM是基于栈的虚拟机，每个线程都有一个JVM栈，这个栈由栈帧（Stack Frame）组成。每次方法调用会创建一个栈帧，一个栈帧由一个操作数栈、一个本地变量数组和指向当方法所在的类的运行时常量池的指针组成。</p><p><img src="http://web.cs.ucla.edu/~msb/cs239-tutorial/images/image02.gif" alt="171227_01.gif"></p><p>在<a href="http://www.artima.com/insidejvm/ed2/jvm.html" target="_blank" rel="noopener">这里</a>可以更深入了解JVM</p><h3 id="基于栈的虚拟机："><a href="#基于栈的虚拟机：" class="headerlink" title="基于栈的虚拟机："></a>基于栈的虚拟机：</h3><p>我们需要一些基于栈的虚拟机的背景知识以便更好的了解Java字节码。对于一个基于栈的虚拟机来说，它存储操作数的内存结构是栈。操作数以LIFO（Last In First Out）的方式从栈顶弹出，被操作之后被压入栈中。在基于栈的虚拟机中，两个数相加的操作如下所示（20、7和结果是操作数）</p><p><img src="http://web.cs.ucla.edu/~msb/cs239-tutorial/images/image00.png" alt="171227_02.png"></p><p>如果你对这部分感兴趣，你可以看<a href="https://markfaction.wordpress.com/2012/07/15/stack-based-vs-register-based-virtual-machine-architecture-and-the-dalvik-vm/" target="_blank" rel="noopener">这里</a>获取更多关于基于栈和基于寄存器的虚拟机的更多细节</p><p>例如如下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printOne();</span><br><span class="line">        printOne();</span><br><span class="line">        printTwo();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        printOne();</span><br><span class="line">        printOne();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们用javac来编译java程序，然后使用javap -c来反编译class文件。Java class文件（即后缀是.class的文件）包含JVM中运行的java字节码，Java class文件是由java编译器对java源代码编译之后产生的。反编译class文件如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span>        </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: invokestatic  #2                  // Method printOne:()V</span><br><span class="line">       3: invokestatic  #2                  // Method printOne:()V</span><br><span class="line">       6: invokestatic  #3                  // Method printTwo:()V</span><br><span class="line">       <span class="number">9</span>: <span class="keyword">return</span>        </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOne</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #5                  // String Hello World</span><br><span class="line">       5: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span>        </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTwo</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: invokestatic  #2                  // Method printOne:()V</span><br><span class="line">       3: invokestatic  #2                  // Method printOne:()V</span><br><span class="line">       <span class="number">6</span>: <span class="keyword">return</span>        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分析：</p><ul><li>首先看一下public Test()这个构造函数，它包含三个操作指令，第一个是aload_0，它把本地变量表中索引为0的值压入操作数栈。本地变量表是用来传递函数参数的。下一个操作指令invokespecial调用这个类父类的构造器，所有没有明确指明父类的类都继承自java.lang.Object，编译器提供了必要的字节码来调用这个基类的构造器。在这条操作指令执行时，操作数栈最顶部的值this被弹出。最后一条指令return返回应该被返回的值。操作指令的索引不连续是因为有的操作指令有参数，需要在字节码数组中占用位置。</li><li>#number 是常量池中的索引。常量池是一个包含字符串常量、类和接口名字、变量名字和其他常量的表。我们可以使用”javap -c -v”来查看整个常量池。</li><li>java语言设置了两种方法，实例方法（invokevirtual）和类方法（invokestatic）。当Java虚拟机调用一个类方法时，它根据对象的引用类型来选择方法，这是在编译时就确定的。而实例方法的调用取决于对象的真正的类，这可能只在运行时才能知道。</li><li>可以从<a href="http://www.ibm.com/developerworks/library/it-haggar_bytecode/" target="_blank" rel="noopener">这篇</a>优秀的文章了解到关于更多java字节码的知识。</li></ul><h2 id="第二部分-访问者模式"><a href="#第二部分-访问者模式" class="headerlink" title="第二部分 访问者模式"></a>第二部分 访问者模式</h2><p>在面向对象编程和软件工程中，访问者模式是一种把数据结构和操作这个数据结构的算法分开的模式。这种分离能方便的添加新的操作而无需更改数据结构。</p><p>实质上，访问者允许一个类族添加新的虚函数而不修改类本身。但是，创建一个访问者类可以实现虚函数所有的特性。访问者接收实例引用作为输入，使用双重调用实现这个目标。</p><p>访问者模式要求程序语言支持单一调用。在这一条件下，我们创建两个不同类的对象，一个是element，另一个是vistor。element有一个accept()方法接收vistor实例作为参数。accept()方法调用vistor的visit()方法；element类将它自己作为参数传入visit方法。</p><p>在下面这个例子中，我们使用的访问者模式和ASM来操作字节码的模式相似。</p><ol><li>添加void accept(Vistor v)到Element类</li><li>创建一个vistor基类，基类中包含每一种元素类的visit()方法</li><li>创建一个vistor派生类，实现基类对Element的所有操作。</li><li>使用者创建vistor对象，调用元素的accept方法并传递vistor实例作为参数。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 1. accept(Visitor) interface</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">( Visitor v )</span></span>; <span class="comment">// first dispatch</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">This</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 1. accept(Visitor) implementation</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>   <span class="title">accept</span><span class="params">( Visitor v )</span> </span>&#123;</span><br><span class="line">     v.visit( <span class="keyword">this</span> );</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">thiss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"This"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">That</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>   <span class="title">accept</span><span class="params">( Visitor v )</span> </span>&#123;</span><br><span class="line">     v.visit( <span class="keyword">this</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">that</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"That"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TheOther</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>   <span class="title">accept</span><span class="params">( Visitor v )</span> </span>&#123;</span><br><span class="line">     v.visit( <span class="keyword">this</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">theOther</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"TheOther"</span>; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Create a "visitor" base class with a visit() method for every "element" type</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">( This e )</span></span>; <span class="comment">// second dispatch</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">( That e )</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">( TheOther e )</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Create a "visitor" derived class for each "operation" to perform on "elements"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;                   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">( This e )</span> </span>&#123;</span><br><span class="line">      System.out.println( <span class="string">"do Up on "</span> + e.thiss() );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">( That e )</span> </span>&#123;</span><br><span class="line">      System.out.println( <span class="string">"do Up on "</span> + e.that() );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">( TheOther e )</span> </span>&#123;</span><br><span class="line">      System.out.println( <span class="string">"do Up on "</span> + e.theOther() );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">( This e )</span> </span>&#123;</span><br><span class="line">      System.out.println( <span class="string">"do Down on "</span> + e.thiss() );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">( That e )</span> </span>&#123;</span><br><span class="line">      System.out.println( <span class="string">"do Down on "</span> + e.that() );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">( TheOther e )</span> </span>&#123;</span><br><span class="line">      System.out.println( <span class="string">"do Down on "</span> + e.theOther() );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VisitorDemo</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Element[] list = &#123; <span class="keyword">new</span> This(), <span class="keyword">new</span> That(), <span class="keyword">new</span> TheOther() &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4. Client creates "visitor" objects and passes each to accept() calls</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">      UpVisitor    up   = <span class="keyword">new</span> UpVisitor();</span><br><span class="line">      DownVisitor  down = <span class="keyword">new</span> DownVisitor();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">         list[i].accept( up );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">         list[i].accept( down );</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> Up on This                <span class="keyword">do</span> Down on This</span><br><span class="line"><span class="keyword">do</span> Up on That                <span class="keyword">do</span> Down on That</span><br><span class="line"><span class="keyword">do</span> Up on TheOther            <span class="keyword">do</span> Down on TheOther</span><br></pre></td></tr></table></figure></p><h3 id="ASM中的访问者模式"><a href="#ASM中的访问者模式" class="headerlink" title="ASM中的访问者模式"></a>ASM中的访问者模式</h3><p>ASM使用访问者模式，ClassReader类和MethodNode类都是被访问的，访问者接口包括ClassVistor,AnnotationVisitor,FieldVistor和MethodVistor。<br>accept()方法属于MethodNode，它的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(ClassVisitor cv)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(MethodVisitor mv)</span></span></span><br></pre></td></tr></table></figure></p><p>visit()方法族，例如visitField()，是ClassVistor的一部分，他们的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, String name, String signature, String superName, String[] interfaces)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">AnnotationVisitor <span class="title">visitAnnotation</span><span class="params">(String desc, <span class="keyword">boolean</span> visible)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visitAttribute</span><span class="params">(Attribute attr)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">FieldVisitor <span class="title">visitField</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, Object value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visitInnerClass</span><span class="params">(String name, String outerName, String innerName, <span class="keyword">int</span> access)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, String[] exceptions)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visitOuterClass</span><span class="params">(String owner, String name, String desc)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visitSource</span><span class="params">(String source, String debug)</span></span></span><br></pre></td></tr></table></figure></p><p><img src="http://web.cs.ucla.edu/~msb/cs239-tutorial/images/image01.gif" alt="171227_03.gif"></p><h2 id="实现调用链跟踪插桩"><a href="#实现调用链跟踪插桩" class="headerlink" title="实现调用链跟踪插桩"></a>实现调用链跟踪插桩</h2><p>在这一部分我们会使用ASM实现一个调用链跟踪。插桩代码会打印出每个方法调用和返回，用这些输出很容易就能解析成上下文调用树。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>你需要安装好JDK和Apache Ant，实例代码在<a href="http://web.cs.ucla.edu/~msb/cs239-tutorial/ASM-tutorial.zip" target="_blank" rel="noopener">这里</a>，还需要<a href="http://download.forge.ow2.org/asm/asm-5.0.3-bin.zip" target="_blank" rel="noopener">这里</a>的asm库。把它们解压，复制asm-all-5.0.3.jar到tutorial文件夹<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> unzip ASM-tutorial.zip</span><br><span class="line"><span class="meta">$</span> unzip asm-5.0.3-bin.zip</span><br><span class="line"><span class="meta">$</span> cp asm-5.0.3/lib/all/asm-all-5.0.3.jar ASM-tutorial/</span><br></pre></td></tr></table></figure></p><h3 id="Hello-ASM：class文件复制"><a href="#Hello-ASM：class文件复制" class="headerlink" title="Hello ASM：class文件复制"></a>Hello ASM：class文件复制</h3><p>我们的第一个ASM程序是简单的复制.class文件，这个项目可以作为后面更复杂有趣的实现的样板。Copy.java如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassReader;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FileInputStream is = <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        ClassReader cr = <span class="keyword">new</span> ClassReader(is);</span><br><span class="line">        ClassWriter cw = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_FRAMES);</span><br><span class="line">        cr.accept(cw, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]);</span><br><span class="line">        fos.write(cw.toByteArray());</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>复制程序接收两个命令行参数，args[0]是要复制的源文件文件名，args[1]是复制后生成的文件名。</p><p>我们使用了两个ASM类，<a href="http://asm.ow2.org/asm50/javadoc/user/org/objectweb/asm/ClassReader.html" target="_blank" rel="noopener">ClassReader</a>从文件中读入Java字节码，<a href="http://asm.ow2.org/asm50/javadoc/user/org/objectweb/asm/ClassWriter.html" target="_blank" rel="noopener">ClassWriter</a>把字节码写入文件。ASM使用访问者模式：ClassWriter实现<a href="http://asm.ow2.org/asm50/javadoc/user/org/objectweb/asm/ClassVisitor.html" target="_blank" rel="noopener">ClassVistor</a>接口，然后通过cr.accept(cw,0)使ClassReader在遍历字节码的过程中调用cw，生成同样的字节码。</p><p>ClassWriter.COMPUTE_FRAMES参数表示ClassWriter自动计算栈帧的长度。cr.accept()的第二个参数表示默认行为，详情可以查看ClassReader和ClassWriter的java文档。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Compile Copy</span><br><span class="line">$ javac -cp asm-all-5.0.3.jar Copy.java</span><br><span class="line"></span><br><span class="line"># Use Copy to copy itself</span><br><span class="line">$ java -cp .:asm-all-5.0.3.jar Copy Copy.class Copy2.class</span><br></pre></td></tr></table></figure></p><blockquote><p>译者注：Linux中环境变量的分隔符是：，Windows底下的是;。</p></blockquote><h3 id="调用链跟踪"><a href="#调用链跟踪" class="headerlink" title="调用链跟踪"></a>调用链跟踪</h3><p>现在我们熟悉了ASM的基本用法，下面我们来实现调用链跟踪。每个函数被调用前后，调用信息会输出到stderr。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printOne();</span><br><span class="line">        printOne();</span><br><span class="line">        printTwo();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        printOne();</span><br><span class="line">        printOne();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们会在函数调用前后把调用信息输出到stderr，插桩完毕后上述代码应该等同于下面的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInstrumented</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"CALL printOne"</span>);</span><br><span class="line">        printOne();</span><br><span class="line">        System.err.println(<span class="string">"RETURN printOne"</span>);</span><br><span class="line"></span><br><span class="line">        System.err.println(<span class="string">"CALL printOne"</span>);</span><br><span class="line">        printOne();</span><br><span class="line">        System.err.println(<span class="string">"RETURN printOne"</span>);</span><br><span class="line"></span><br><span class="line">        System.err.println(<span class="string">"CALL printTwo"</span>);</span><br><span class="line">        printTwo();</span><br><span class="line">        System.err.println(<span class="string">"RETURN printTwo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"CALL println"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">        System.err.println(<span class="string">"RETURN println"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"CALL printOne"</span>);</span><br><span class="line">        printOne();</span><br><span class="line">        System.err.println(<span class="string">"RETURN printOne"</span>);</span><br><span class="line"></span><br><span class="line">        System.err.println(<span class="string">"CALL printOne"</span>);</span><br><span class="line">        printOne();</span><br><span class="line">        System.err.println(<span class="string">"RETURN printOne"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们通过修改上面的Copy来实现，为了修改class文件，我们需要在ClassReader和ClassWriter中间插入某些代码。我们会用<a href="http://en.wikipedia.org/wiki/Adapter_pattern" target="_blank" rel="noopener">适配器模式</a>。适配器包裹一个对象，重写一些方法。这让我们修改被包裹的对象的行为变得很简单。在这里我们会适配ClassWriter，在方法调用前后插入打印代码。</p><p>鉴于方法的调用在方法中，我们的插桩会在方法声明处。这会有点复杂，因为方法声明在类中，所以我们需要遍历一个类来对它的方法插桩。</p><p>我们第一步用下面的ClassAdapter类适配ClassWriter。默认情况下，继承自ClassVistor的ClassAdapter的方法只会调用ClassWriter中的同一个方法。大多数情况我们想要这样。我们只会覆盖ClassWriter.visitMethod方法，每声明一个方法visitMethod就会被调用一次。它的返回值是处理方法体的MethodVistor对象。我们会适配ClassWriter.visitMethod返回的MethodVisitor，插入其他的指令来输出调用信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">lass ClassAdapter extends ClassVisitor implements Opcodes &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassAdapter</span><span class="params">(<span class="keyword">final</span> ClassVisitor cv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(ASM5, cv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> access, <span class="keyword">final</span> String name,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> String desc, <span class="keyword">final</span> String signature, <span class="keyword">final</span> String[] exceptions)</span> </span>&#123;</span><br><span class="line">        MethodVisitor mv = cv.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">        <span class="keyword">return</span> mv == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> MethodAdapter(mv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodAdapter</span> <span class="keyword">extends</span> <span class="title">MethodVisitor</span> <span class="keyword">implements</span> <span class="title">Opcodes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodAdapter</span><span class="params">(<span class="keyword">final</span> MethodVisitor mv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(ASM5, mv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitMethodInsn</span><span class="params">(<span class="keyword">int</span> opcode, String owner, String name, String desc, <span class="keyword">boolean</span> itf)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* <span class="doctag">TODO:</span> System.err.println("CALL" + name); */</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* do call */</span></span><br><span class="line">        mv.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* <span class="doctag">TODO:</span> System.err.println("RETURN" + name);  */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>目前为止，我们的MethodAdapter没有加任何指令。我们很清楚用Java语法如何实现我们的功能，但是我们不知道怎么用ASM API实现它，因此，我们需要使用ASMifier工具。</p><p>我们可以使用ASMifiter将TestInstrumented中的代码转换成ASM API调用。为了简介，我们省略了一些代码<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> javac TestInstrumented.java</span><br><span class="line"><span class="meta">$</span> java -cp .:asm-all-5.0.3.jar org.objectweb.asm.util.ASMifier TestInstrumented</span><br><span class="line">/** WARNING: THINGS ARE ELIDED **/</span><br><span class="line">&#123;</span><br><span class="line">mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "printOne", "()V", null, null);</span><br><span class="line">mv.visitCode();</span><br><span class="line"></span><br><span class="line">mv.visitFieldInsn(GETSTATIC, "java/lang/System", "err", "Ljava/io/PrintStream;");</span><br><span class="line">mv.visitLdcInsn("CALL println");</span><br><span class="line">mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false);</span><br><span class="line"></span><br><span class="line">mv.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");</span><br><span class="line">mv.visitLdcInsn("Hello World");</span><br><span class="line">mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false);</span><br><span class="line"></span><br><span class="line">mv.visitFieldInsn(GETSTATIC, "java/lang/System", "err", "Ljava/io/PrintStream;");</span><br><span class="line">mv.visitLdcInsn("RETURN println");</span><br><span class="line">mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false);</span><br><span class="line"></span><br><span class="line">mv.visitInsn(RETURN);</span><br><span class="line">mv.visitMaxs(2, 0);</span><br><span class="line">mv.visitEnd();</span><br><span class="line">&#125;</span><br><span class="line">/** WARNING: MORE THINGS ARE ELIDED **/</span><br></pre></td></tr></table></figure></p><p>ASMfiter的输出是与TestInstrumented功能相同的ASM程序。从这个程序中，我们可以知道”System.err.println”的ASM API如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv.visitFieldInsn(GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"err"</span>, <span class="string">"Ljava/io/PrintStream;"</span>);</span><br><span class="line">mv.visitLdcInsn(<span class="string">"CALL println"</span>);</span><br><span class="line">mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure></p><p>现在我们可以完成MethodAdapter的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodAdapter</span> <span class="keyword">extends</span> <span class="title">MethodVisitor</span> <span class="keyword">implements</span> <span class="title">Opcodes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodAdapter</span><span class="params">(<span class="keyword">final</span> MethodVisitor mv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(ASM5, mv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitMethodInsn</span><span class="params">(<span class="keyword">int</span> opcode, String owner, String name, String desc, <span class="keyword">boolean</span> itf)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* System.err.println("CALL" + name); */</span></span><br><span class="line">        mv.visitFieldInsn(GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"err"</span>, <span class="string">"Ljava/io/PrintStream;"</span>);</span><br><span class="line">        mv.visitLdcInsn(<span class="string">"CALL "</span> + name);</span><br><span class="line">        mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="keyword">false</span>);</span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* do call */</span></span><br><span class="line">        mv.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* System.err.println("RETURN" + name);  */</span></span><br><span class="line">        mv.visitFieldInsn(Opcodes.GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"err"</span>, <span class="string">"Ljava/io/PrintStream;"</span>);</span><br><span class="line">        mv.visitLdcInsn(<span class="string">"RETURN "</span> + name);</span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>搞定了，在例子Test上试验一下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Build Instrumenter</span><br><span class="line"><span class="meta">$</span> javac -cp asm-all-5.0.3.jar Instrumenter.java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Build Example</span><br><span class="line"><span class="meta">$</span> javac Test.java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Move Test.class out of the way</span><br><span class="line"><span class="meta">$</span> cp Test.class Test.class.bak</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Instrument Test</span><br><span class="line"><span class="meta">$</span> java -cp .:asm-all-5.0.3.jar Instrumenter Test.class.bak Test.class</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Run!</span><br><span class="line"><span class="meta">$</span> java Test</span><br><span class="line">CALL printOne</span><br><span class="line">CALL println</span><br><span class="line">Hello World</span><br><span class="line">RETURN println</span><br><span class="line">RETURN printOne</span><br><span class="line">CALL printOne</span><br><span class="line">CALL println</span><br><span class="line">Hello World</span><br><span class="line">RETURN println</span><br><span class="line">RETURN printOne</span><br><span class="line">CALL printTwo</span><br><span class="line">CALL printOne</span><br><span class="line">CALL println</span><br><span class="line">Hello World</span><br><span class="line">RETURN println</span><br><span class="line">RETURN printOne</span><br><span class="line">CALL printOne</span><br><span class="line">CALL println</span><br><span class="line">Hello World</span><br><span class="line">RETURN println</span><br><span class="line">RETURN printOne</span><br><span class="line">RETURN printTwo</span><br></pre></td></tr></table></figure></p><p>输出正如我们期望。</p><h3 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h3><p>现在你知道如何初步使用ASM了，更多内容可以参考</p><ul><li><a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM Homepage</a></li><li><a href="http://download.forge.ow2.org/asm/asm-5.0.3-bin.zip" target="_blank" rel="noopener">ASM 5.0.3 Binary Distribution</a></li><li><a href="http://download.forge.objectweb.org/asm/asm4-guide.pdf" target="_blank" rel="noopener">User Guide</a></li><li><a href="http://asm.ow2.org/asm50/javadoc/user/index.html" target="_blank" rel="noopener">ASM JavaDoc</a></li></ul><blockquote><p>译者注：官方文档是最好的文档。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;翻译自 &lt;a href=&quot;http://web.cs.ucla.edu/~msb/cs239-tutorial/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://web.cs.ucla.edu/~msb/cs239-tutorial/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这篇文章中，你将学会如何使用ASM框架对java class文件插桩。文章第一部分介绍Java字节码以及如何阅读class文件。第二部分介绍贯穿ASM框架的vistor模式。第三部分我们将用ASM构建一个简单的调用链跟踪插桩。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://c0d3p1ut0s.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="http://c0d3p1ut0s.github.io/tags/JVM/"/>
    
      <category term="Java字节码" scheme="http://c0d3p1ut0s.github.io/tags/Java%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>BurpUnlimited分析</title>
    <link href="http://c0d3p1ut0s.github.io/BurpUnlimited%E5%88%86%E6%9E%90/"/>
    <id>http://c0d3p1ut0s.github.io/BurpUnlimited分析/</id>
    <published>2017-12-14T14:56:46.000Z</published>
    <updated>2018-03-05T11:29:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近，larry破解的BurpSuite Pro过期了，不久，mxcx放出了一个BurpSuite Pro的无限版，由BurpUnlimited启动，并且开源了BurpUnlimited的源代码，可供分析。</p><p>BurpUnlimited可以分为两部分，一是有main函数的<code>larry.lau.BurpLoader</code>及依赖模块，另一部分是有premain函数的<code>mxcx.javaagent</code>及依赖模块，premain函数是Java Instrumentation的入口函数。将BurpUnlimited分为这两部分是显而易见的，因为在BurpUnlimited的readme中，开发者说一种运行BurpUnlimited的方法是<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:BurpUnlimited.jar -agentpath:lib/libfaketime&lt;osverion&gt; -jar BurpUnlimited.jar</span><br></pre></td></tr></table></figure></p><p>显然，BurpUnlimited能直接运行，说明它有main函数，能作为javaagent加载，说明它又是一个有premain函数的Instrumentation。<br>在分析这两部分之前，先说一些背景。</p><h2 id="0x01-背景"><a href="#0x01-背景" class="headerlink" title="0x01 背景"></a>0x01 背景</h2><p>Java Instrumentation允许开发者访问从JVM中加载的类，并且允许对它的字节码做修改，加入我们自己的代码，这些都是在运行时完成的。并且它仍然遵从安全管理器的限制。Java Instrumentation通过-javaagent加载。</p><p>在调试Java Instrumentation时，建议使用远程调试，远程调试的命令行参数如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005</span><br></pre></td></tr></table></figure></p><p>在这里，建议将suspend参数设置为y，这样可以保证调试者连接上来之后才开始启动应用，否则在调试代码运行和调试器连接上来之间有时间差，不好控制代码的运行。</p><h2 id="0x02-分析"><a href="#0x02-分析" class="headerlink" title="0x02 分析"></a>0x02 分析</h2><p>在这里仅分析一下BurpUnlimited对larry的BurpLoader的破解。在larry.lau.BurpLoader中，绝大多数代码是larrylau对BurpSuite Pro的破解，mxcx主要添加了<code>BurpUnlimited.setupValidationEnv();</code>和<code>BurpUnlimited.uninstallFakeTime();</code>这两行代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] array)</span> </span>&#123; </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           BurpUnlimited.setupValidationEnv();</span><br><span class="line">           <span class="keyword">final</span> String s = BurpLoader.z[<span class="number">3</span>];</span><br><span class="line">           <span class="comment">//......</span></span><br><span class="line">           StartBurp.main(array);</span><br><span class="line">           BurpUnlimited.uninstallFakeTime();</span><br><span class="line">       &#125;<span class="keyword">catch</span>(<span class="comment">/*...*/</span>)&#123;</span><br><span class="line">           <span class="comment">//.....</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们先来看看<code>BurpUnlimited.setupValidationEnv();</code>，<code>BurpUnlimited.setupValidationEnv()</code>方法主要做了这么几件事</p><ul><li><p>获取参数，判断是否添加了-javaagent和-agentlib等参数，如果没有添加，说明BurpUnlimited是以双击的方式直接启动的，那么程序构造一个shell命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:BurpUnlimited.jar -agentpath:lib/libfaketime&lt;osverion&gt; -jar BurpUnlimited.jar</span><br></pre></td></tr></table></figure><p>运行这个有完整参数的命令重新启动。</p></li><li>利用反射，将JVM的Managed Bean对象里面的jvm成员里面的vmArgs置为[]以绕过BurpSuite中的反调试。</li><li>将系统参数faketime.absolute.ms设置为1420045200000，即<code>Thu Jan 01 01:00:00 CST 2015</code>。</li></ul><p>下面分析一下这个类中几行关键的代码。line118 <code>RuntimeMXBean mxb = ManagementFactory.getRuntimeMXBean();</code>获取当前运行的jvm的managed bean。line120-line152，判断jvm的参数中是否有-javaagent和-agentpath，如果没有，补充完整，运行完整shell命令。line154，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StrictPA.setValue(StrictPA.getValue(mxb, <span class="string">"jvm"</span>), <span class="string">"vmArgs"</span>, Collections.unmodifiableList(<span class="keyword">new</span> ArrayList&lt;Object&gt;()));</span><br></pre></td></tr></table></figure></p><p>通过反射，将managed bean中的jvm中的vmArg重置为[]，重置之前是jvm的参数是<code>[&#39;-javaagent:BurpUnlimited.jar&#39;,&#39; -agentpath:lib/libfaketime&lt;osverion&gt;&#39;]</code>。重置后可以绕过BurpSuite的反调试。实际上，<br>在安全管理器没做限定的情况下，反射可以使用<code>setAccessible(true)</code>去除类似于private的访问限制，并且随心所欲的修改受访问限制的变量。而在默认情况下，安全管理器是不启用的。line160-line166，将<code>faketime.absolute.ms</code>设置为2015年，并判断是否成功修改<code>System.currentTimeMillis()</code>的实现。这里使用了faketime项目<a href="https://github.com/faketime-java/faketime。" target="_blank" rel="noopener">https://github.com/faketime-java/faketime。</a></p><p><code>BurpUnlimited.setupValidationEnv();</code>之后就是larrylau的破解，破解完毕之后，调用<code>StartBurp.main(array);</code>启动Burp，之后就调用<code>BurpUnlimited.uninstallFakeTime();</code>将时间改回了真实的时间。代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StartBurp.main(array);</span><br><span class="line">BurpUnlimited.uninstallFakeTime();</span><br></pre></td></tr></table></figure></p><p>可见BurpSuite仅在启动时对License进行了判断。</p><p>下面是分析一下Java Instrumentation，首先，java instrumentation有一个premain函数作为入口，类似于main函数，在这个函数中，可以为Instrumentation添加一个<code>transformer</code>对字节码进行操作。在transformer类中，必须实现<code>transform</code>方法来对字节码进行修改。这个Instrumentation将<code>larry/lau/burp/ui/TestDisclaimer</code>和<code>burp/uzd</code>的字节码直接修改成了<code>TestDisclaimerClass</code>和<code>uzdClass</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String TestDisclaimerClass = &quot;cafebabe0000003300250a0....20019&quot;;</span><br><span class="line">String uzdClass = &quot;cafebabe00000033006f0a0....2003f&quot;;</span><br></pre></td></tr></table></figure></p><p>这两个字符串对应的字节码是<code>BurpUnlimited/others/aloneclasses/burp/uzd.java</code>和<code>BurpUnlimited/others/aloneclasses/larry/lau/burp/ui/TestDisclaimer.java</code>的字节码，它替换了原来的larrylau声明<br><img src="https://i.loli.net/2017/12/14/5a3291bb8b687.png" alt="20171206_1.png"></p><p>和BurpSuite中的License界面</p><p><img src="https://i.loli.net/2017/12/14/5a3291bb96473.png" alt="20171206_2.png"></p><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>mxcx使用一个java原生agent修改Java API获取的时间，使License在校验时获取的本地时间永远在License过期时间之前，这样，这个License将永远有效，不会过期。</p><h2 id="0x04-关于作者"><a href="#0x04-关于作者" class="headerlink" title="0x04 关于作者"></a>0x04 关于作者</h2><ul><li>c0d3p1ut0s <code>c0d3p1ut0s@gmail.com</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;最近，larry破解的BurpSuite Pro过期了，不久，mxcx放出了一个BurpSuite 
      
    
    </summary>
    
    
      <category term="Web安全" scheme="http://c0d3p1ut0s.github.io/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java安全" scheme="http://c0d3p1ut0s.github.io/tags/Java%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>一类PHP RASP的实现</title>
    <link href="http://c0d3p1ut0s.github.io/%E4%B8%80%E7%B1%BBPHP-RASP%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://c0d3p1ut0s.github.io/一类PHP-RASP的实现/</id>
    <published>2017-11-30T12:27:02.000Z</published>
    <updated>2018-01-08T13:04:29.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章2017.11.10发在 <a href="https://paper.seebug.org/449/" target="_blank" rel="noopener">https://paper.seebug.org/449/</a> 。重发在博客如下</p></blockquote><h2 id="RASP概念"><a href="#RASP概念" class="headerlink" title="RASP概念"></a>RASP概念</h2><p>RASP（Runtime Application self-protection）是一种在运行时检测攻击并且进行自我保护的一种技术。早在2012年，Gartner就开始关注RASP，惠普、WhiteHat Security等多家国外安全公司陆续推出RASP产品，时至今日，惠普企业的软件部门出售给了Micro Focus，RASP产品Application Defender随之易主。而在国内，去年知道创宇KCon大会兵器谱展示了JavaRASP，前一段时间，百度开源了OpenRASP，去年年底，360的0kee团队开始测试Skywolf，虽然没有看到源码和文档，但它的设计思路或许跟RASP类似。而商业化的RASP产品有OneAPM的OneRASP和青藤云的自适应安全产品。在国内，这两家做商业化RASP产品做得比较早。</p><p>那么RASP到底是什么呢？它到底是怎样工作的呢？<br><a id="more"></a></p><h2 id="我的WAF世界观"><a href="#我的WAF世界观" class="headerlink" title="我的WAF世界观"></a>我的WAF世界观</h2><p>为了表述方便，暂且把RASP归为WAF的一类。从WAF所在的拓扑结构，可以简单将WAF分为如下三类，如下图所示：</p><p><img src="https://i.loli.net/2017/11/30/5a2003fac8ae3.png" alt="WAF.png"></p><ul><li>以阿里云为代表的云WAF以中间人的形式，在HTTP请求到达目标服务器之前进行检查拦截。</li><li>以ModSecurity为代表的传统WAF在HTTP请求到达HTTP服务器后，被Web后端容器解释/执行之前检查拦截HTTP请求。</li><li>RASP工作在Web后端解释器/编译器中，在漏洞代码执行前阻断执行流。</li></ul><p>从上图中WAF所处的位置可以看出，云WAF和传统WAF的检查拦截HTTP请求的主要依据是HTTP Request，其实，如果站在一个非安全从业者的角度来看，这种检测方式是奇怪的。我们可以把Web服务看做是一个接受输入-处理-输出结果的程序，那么它的输入是HTTP请求，它的输出是HTTP响应。靠检测一个程序的输入和输出来判断这个程序的运行过程是否有害，这不奇怪吗？然而它又是可行且有效的，大多数的Web攻击都能从HTTP请求中找到蛛丝马迹。这种检测思路是云WAF和传统WAF能有效工作的原因，也是它们的缺点。</p><p>笔者一直认为，问题发生的地方是监控问题、解决问题的最好位置。Web攻击发生在Web后端代码执行时，最好的防护方法就是在Web后端代码执行之前推测可能发生的问题，然后阻断代码的执行。这里的推测并没有这么难，就好像云WAF在检查包含攻击payload的HTTP请求时推测它会危害Web服务一样。这就是RASP的设计思路。</p><p>好了，上面谈了一下笔者个人的一些看法，下面开始谈一谈PHP RASP的实现。</p><p>RASP在后端代码运行时做安全监测，但又不侵入后端代码，就得切入Web后端解释器。以Java为例，Java支持以JavaAgent的方式，在class文件加载时修改字节码，在关键位置插入安全检查代码，实现RASP功能。同样，PHP也支持对PHP内核做类似的操作，PHP支持PHP扩展，实现这方面的需求。你可能对JavaAgent和PHP扩展比较陌生，实际上，在开发过程中，JavaAgent和PHP扩展与你接触的次数比你意识到的多得多。</p><h2 id="PHP扩展简介"><a href="#PHP扩展简介" class="headerlink" title="PHP扩展简介"></a>PHP扩展简介</h2><p>有必要介绍一下PHP解释的简单工作流程，根据PHP解释器所处的环境不同，PHP有不同的工作模式，例如常驻CGI，命令行、Web Server模块、通用网关接口等多个模式。在不同的模式下，PHP解释器以不同的方式运行，包括单线程、多线程、多进程等。</p><p>为了满足不同的工作模式，PHP开发者设计了Server API即SAPI来抹平这些差异，方便PHP内部与外部进行通信。</p><p>虽然PHP运行模式各不相同，但是，PHP的任何扩展模块，都会依次执行模块初始化（MINIT）、请求初始化（RINIT）、请求结束（RSHUTDOWN）、模块结束（MSHUTDOWN）四个过程。如下图所示：</p><p><img src="https://i.loli.net/2017/11/30/5a2003fabd0a6.png" alt="PHPext.png"></p><p>在PHP实例启动时，PHP解释器会依次加载每个PHP扩展模块，调用每个扩展模块的MINIT函数，初始化该模块。当HTTP请求来临时，PHP解释器会调用每个扩展模块的RINIT函数，请求处理完毕时，PHP会启动回收程序，倒序调用各个模块的RSHUTDOWN方法，一个HTTP请求处理就此完成。由于PHP解释器运行的方式不同，RINIT-RSHUTDOWN这个过程重复的次数也不同。当PHP解释器运行结束时，PHP调用每个MSHUTDOWN函数，结束生命周期。</p><p>PHP核心由两部分组成，一部分是PHP core，主要负责请求管理，文件和网络操作，另一部分是Zend引擎，Zend引擎负责编译和执行，以及内存资源的分配。Zend引擎将PHP源代码进行词法分析和语法分析之后，生成抽象语法树，然后编译成Zend字节码，即Zend opcode。即PHP源码-&gt;AST-&gt;opcode。opcode就是Zend虚拟机中的指令。使用VLD扩展可以看到Zend opcode，这个扩展读者应该比较熟悉了。下面代码的opcode如图所示<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a=<span class="number">1</span>;</span><br><span class="line">$b=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">print</span> $a+$b;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2017/11/30/5a2003fada24d.png" alt="opcode.png"></p><p>Zend引擎的所有opcode在<a href="http://php.net/manual/en/internals2.opcodes.list.php" target="_blank" rel="noopener">http://php.net/manual/en/internals2.opcodes.list.php</a> 中可以查到，在PHP的内部实现中，每一个opcode都由一个函数具体实现，opcode数据结构如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_op</span> &#123;</span></span><br><span class="line">    <span class="keyword">opcode_handler_t</span> handler;<span class="comment">//执行opcode时调用的处理函数</span></span><br><span class="line">    znode result;</span><br><span class="line">    znode op1;</span><br><span class="line">    znode op2;</span><br><span class="line">    ulong extended_value;</span><br><span class="line">    uint lineno;</span><br><span class="line">    zend_uchar opcode; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如结构体所示，具体实现函数的指针保存在类型为opcode_handler_t的handler中。</p><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>PHP RASP的设计思路很直接，安全圈有一句名言叫一切输入都是有害的，我们就跟踪这些有害变量，看它们是否对系统造成了危害。我们跟踪了HTTP请求中的所有参数、HTTP Header等一切client端可控的变量，随着这些变量被使用、被复制，信息随之流动，我们也跟踪了这些信息的流动。我们还选取了一些敏感函数，这些函数都是引发漏洞的函数，例如require函数能引发文件包含漏洞，mysqli-&gt;query方法能引发SQL注入漏洞。简单来说，这些函数都是大家在代码审计时关注的函数。我们利用某些方法为这些函数添加安全检查代码。当跟踪的信息流流入敏感函数时，触发安全检查代码，如果通过安全检查，开始执行敏感函数，如果没通过安全检查，阻断执行，通过SAPI向HTTP Server发送403 Forbidden信息。当然，这一切都在PHP代码运行过程中完成。</p><p>这里主要有两个技术问题，一个是如何跟踪信息流，另一个是如何安全检查到底是怎样实现的。</p><p>我们使用了两个技术思路来解决两个问题，第一个是动态污点跟踪，另一个是基于词法分析的漏洞检测。</p><h2 id="动态污点跟踪"><a href="#动态污点跟踪" class="headerlink" title="动态污点跟踪"></a>动态污点跟踪</h2><p>对PHP内核有一些了解的人应该都知道鸟哥，鸟哥有一个项目taint，做的就是动态污点跟踪。动态污点跟踪技术在白盒的调试和分析中应用比较广泛。它的主要思路就是先认定一些数据源是可能有害的，被污染的，在这里，我们认为所有的HTTP输入都是被污染的，所有的HTTP输入都是污染源。随着这些被污染变量的复制、拼接等一系列操作，其他变量也会被污染，污染会扩大，这就是污染的传播。这些经过污染的变量作为参数传入敏感函数以后，可能导致安全问题，这些敏感函数就是沉降点。</p><p>做动态污点跟踪主要是定好污染源、污染传播策略和沉降点。在PHP RASP中，污染源和沉降点显而易见，而污染传播策略的制定影响对RASP的准确性有很大的影响。传播策略过于严格会导致漏报，传播策略过于宽松会增加系统开销。PHP RASP的污染传播策略是变量的复制、赋值和大部分的字符串处理等操作传播污染。</p><p>动态污点跟踪的一个小小好处是如果一些敏感函数的参数没有被污染，那么我们就无需对它进行安全检查。当然，这只是它的副产物，它的大作用在漏洞检测方面。</p><p>动态污点跟踪的实现比较复杂，有兴趣的可以去看看鸟哥的taint，鸟哥的taint也是以PHP扩展的方式做动态污点跟踪。PHP RASP中，这部分是基于鸟哥的taint修改、线程安全优化、适配不同PHP版本实现的。在发行过程中，我们也将遵守taint的License。</p><p>在PHP解释器中，全局变量都保存在一个HashTable类型的符号表symbol_table中，包括预定义变量$GLOBALS、$_GET、$_POST等。我们利用变量结构体中的flag中未被使用的一位来标识这个变量是否被污染。在RINIT过程中，我们通过这个方法首先将$_GET,$_POST,$_SERVER等数组中的值标记为污染，这样，我们就完成了污染源的标记。</p><p>污染的传播过程其实就是hook对应的函数，在PHP中，可以从两个层面hook函数，一是通过修改zend_internal_function的handler来hook PHP中的内部函数，handler指向的函数用C或者C++编写，可以直接执行。zend_internal_function的结构体如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//zend_complie.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_internal_function</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Common elements */</span></span><br><span class="line">    zend_uchar type;</span><br><span class="line">    zend_uchar arg_flags[<span class="number">3</span>]; <span class="comment">/* bitset of arg_info.pass_by_reference */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> fn_flags;</span><br><span class="line">    zend_string* function_name;</span><br><span class="line">    zend_class_entry *scope;</span><br><span class="line">    zend_function *prototype;</span><br><span class="line">    <span class="keyword">uint32_t</span> num_args;</span><br><span class="line">    <span class="keyword">uint32_t</span> required_num_args;</span><br><span class="line">    zend_internal_arg_info *arg_info;</span><br><span class="line">    <span class="comment">/* END of common elements */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*handler)(INTERNAL_FUNCTION_PARAMETERS); <span class="comment">//函数指针，展开：void (*handler)(zend_execute_data *execute_data, zval *return_value)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">zend_module_entry</span> *<span class="title">module</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *reserved[ZEND_MAX_RESERVED_RESOURCES];</span><br><span class="line">&#125; zend_internal_function;</span><br></pre></td></tr></table></figure></p><p>我们可以通过修改zend_internal_function结构体中handler的指向，待完成我们需要的操作后再调用原来的处理函数即可完成hook。<br>另一种是hook opcode，需要使用zend提供的API zend_set_user_opcode_handler来修改opcode的handler来实现。</p><p>我们在MINIT函数中用这两种方法来hook传播污染的函数，如下图所示</p><p><img src="https://i.loli.net/2017/11/30/5a2003fad93cd.png" alt="override.png"></p><p><img src="https://i.loli.net/2017/11/30/5a2003fad239a.png" alt="handler.png"></p><p>当传播污染的函数被调用时，如果这个函数的参数是被污染的，那么把它的返回值也标记成污染。以hook内部函数str_replace函数为例，hook后的rasp_str_replace如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(rasp_str_replace)</span><br><span class="line">&#123;</span><br><span class="line">zval *str, *from, *len, *repl;</span><br><span class="line"><span class="keyword">int</span> tainted = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"zzz|z"</span>, &amp;str, &amp;repl, &amp;from, &amp;len) == FAILURE) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="comment">//取参</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_STRING == Z_TYPE_P(repl) &amp;&amp; PHP_RASP_POSSIBLE(repl)) &#123;</span><br><span class="line">tainted = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_STRING == Z_TYPE_P(from) &amp;&amp; PHP_RASP_POSSIBLE(from)) &#123;</span><br><span class="line">tainted = <span class="number">1</span>;</span><br><span class="line">&#125;<span class="comment">//判断</span></span><br><span class="line"></span><br><span class="line">RASP_O_FUNC(str_replace)(INTERNAL_FUNCTION_PARAM_PASSTHRU);<span class="comment">//调用原函数执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tainted &amp;&amp; IS_STRING == Z_TYPE_P(return_value) &amp;&amp; Z_STRLEN_P(return_value)) &#123;</span><br><span class="line">        TAINT_MARK(Z_STR_P(return_value));</span><br><span class="line">&#125;<span class="comment">//污染标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先获取参数，判断参数from和repl是否被污染，如果被污染，将返回值标记为污染，这样就完成污染传播过程。</p><p>当被污染的变量作为参数被传入关键函数时，触发关键函数的安全检查代码，这里的实现其实跟上面的类似。PHP的中函数调用都是由三个Zend opcode：ZEND_DO_FCALL,ZEND_DO_ICALL 和 ZEND_DO_FCALL_BY_NAME中某一个opcode来进行的。每个函数的调用都会运行这三个 opcode 中的一个。通过劫持三个 opcode来hook函数调用,就能获取调用的函数和参数。这里我们只需要hook opcode，就是上面第二幅图示意的部分，为了让读者更加清晰，我把它复制下来。<br><img src="https://i.loli.net/2017/11/30/5a2003fad239a.png" alt="handler.png"></p><p>如图，在MINIT方法中，我们利用Zend API zend_set_user_opcode_handler来hook这三个opcode，监控敏感函数。在PHP内核中，当一个函数通过上述opcode调用时，Zend引擎会在函数表中查找函数，然后返回一个zend_function类型的指针，zend_function的结构如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> _zend_function &#123;</span><br><span class="line">zend_uchar type;<span class="comment">/* MUST be the first element of this struct! */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">zend_uchar type;  <span class="comment">/* never used */</span></span><br><span class="line">zend_uchar arg_flags[<span class="number">3</span>]; <span class="comment">/* bitset of arg_info.pass_by_reference */</span></span><br><span class="line"><span class="keyword">uint32_t</span> fn_flags;</span><br><span class="line">zend_string *function_name;</span><br><span class="line">zend_class_entry *scope;</span><br><span class="line"><span class="keyword">union</span> _zend_function *prototype;</span><br><span class="line"><span class="keyword">uint32_t</span> num_args;</span><br><span class="line"><span class="keyword">uint32_t</span> required_num_args;</span><br><span class="line">zend_arg_info *arg_info;</span><br><span class="line">&#125; common;</span><br><span class="line"></span><br><span class="line">zend_op_array op_array;</span><br><span class="line">zend_internal_function internal_function;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其中，common.function_name指向这个函数的函数名，common.scope指向这个方法所在的类，如果一个函数不属于某个类，例如PHP中的fopen函数，那么这个scope的值是null。这样，我们就获取了当前函数的函数名和类名。</p><p>以上的行文逻辑是以RASP的角度来看的，先hook opcode和内部函数，来实现动态污点跟踪，然后通过hook函数调用时运行的三个opcode来对监控函数调用。实际上，在PHP内核中，一个函数的调用过程跟以上的行文逻辑是相反的。</p><p>当一个函数被调用时，如上文所述，根据这个函数调用的方式不同，例如直接调用或者通过函数名调用，由Zend opcode，ZEND_DO_FCALL,ZEND_DO_ICALL 和 ZEND_DO_FCALL_BY_NAME中的某一个opcode来进行。Zend引擎会在函数表中搜索该函数，返回一个zend_function指针，然后判断zend_function结构体中的type，如果它是内部函数，则通过zend_internal_function.handler来执行这个函数，如果handler已被上述hook方法替换，则调用被修改的handler；如果它不是内部函数，那么这个函数就是用户定义的函数，就调用zend_execute来执行这个函数包含的zend_op_array。</p><p>现在我们从RASP的角度和PHP内核中函数执行的角度来看了动态污点跟踪和函数的hook，接下来，我们需要对不同类型的关键函数进行安全检测。</p><h2 id="基于词法分析的攻击检测"><a href="#基于词法分析的攻击检测" class="headerlink" title="基于词法分析的攻击检测"></a>基于词法分析的攻击检测</h2><p>传统WAF和云WAF在针对HTTP Request检测时有哪些方法呢？常见的有正则匹配、规则打分、机器学习等，那么，处于PHP解释器内部的PHP RASP如何检测攻击呢？</p><p>首先，我们可以看PHP RASP可以获取哪些数据作为攻击检测的依据。与其他WAF一样，PHP RASP可以获取HTTP请求的Request。不同的是，它还能获取当前执行函数的函数名和参数，以及哪些参数是被污染的。当然，像传统WAF一样，利用正则表达式来作为规则来匹配被污染的函数参数也是PHP RASP检测的一种方法。不过，对于大多数的漏洞，我们采用的是利用词法分析来检测漏洞。准确的来说，对于大多数代码注入漏洞，我们使用词法分析来检测漏洞。</p><p>代码注入漏洞，是指攻击者可以通过HTTP请求将payload注入某种代码中，导致payload被当做代码执行的漏洞。例如SQL注入漏洞，攻击者将SQL注入payload插入SQL语句中，并且被SQL引擎解析成SQL代码，影响原SQL语句的逻辑，形成注入。同样，文件包含漏洞、命令执行漏洞、代码执行漏洞的原理也类似，也可以看做代码注入漏洞。</p><p>对于代码注入漏洞，攻击者如果需要成功利用，必须通过注入代码来实现，这些代码一旦被注入，必然修改了代码的语法树的结构。而追根到底，语法树改变的原因是词法分析结果的改变，因此，只需要对代码部分做词法分析，判断HTTP请求中的输入是否在词法分析的结果中占据了多个token，就可以判断是否形成了代码注入。</p><p>在PHP RASP中，我们通过编写有限状态机来完成词法分析。有限状态机分为确定有限状态机DFA和非确定有限状态机NFA，大多数的词法分析器，例如lex生成的词法分析器，都使用DFA，，因为它简单、快速、易实现。同样，在PHP RASP中，我们也使用DFA来做词法分析。</p><p>词法分析的核心是有限状态机，而有限状态机的构建过程比较繁琐，在此不赘述，与编译器中的词法分析不同的是，PHP RASP中词法分析的规则并不一定与这门语言的词法定义一致，因为词法分析器的输出并不需要作为语法分析器的输入来构造语法树，甚至有的时候不必区分该语言的保留字与变量名。</p><p>在经过词法分析之后，我们可以得到一串token，每个token都反映了对应的代码片段的性质，以SQL语句<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="string">'1'</span><span class="keyword">or</span><span class="string">'1'</span>=<span class="string">'1'</span></span><br></pre></td></tr></table></figure></p><p>为例,它对应的token串如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select &lt;reserve word&gt;</span><br><span class="line">username &lt;identifier&gt;</span><br><span class="line">from &lt;reserve word&gt;</span><br><span class="line">users    &lt;identifier&gt;</span><br><span class="line">where &lt;reserve word&gt;</span><br><span class="line">id  &lt;identifier&gt;</span><br><span class="line">=   &lt;sign&gt;</span><br><span class="line">&apos;1&apos; &lt;string&gt;</span><br><span class="line">or  &lt;reserve word&gt;</span><br><span class="line">&apos;1&apos; &lt;string&gt;</span><br><span class="line">=   &lt;sign&gt;</span><br><span class="line">&apos;1&apos; &lt;string&gt;</span><br></pre></td></tr></table></figure></p><p>而如果这个SQL语句是被污染的（只有SQL语句被污染才会进入安全监测这一步），而且HTTP请求中某个参数的值是1’or’1’=’1，对比上述token串可以发现，HTTP请求中参数横跨了多个token，这很可能是SQL注入攻击。那么，PHP RASP会将这条HTTP请求判定成攻击，直接阻止执行SQL语句的函数继续运行。如果上述两个条件任一不成立，则通过安全检查，执行SQL语句的函数继续运行。这样就完成了一次HTTP请求的安全检查。其他代码注入类似，当然，不同的代码注入使用的DFA是不一样的，命令注入的DFA是基于shell语法构建的，文件包含的DFA是基于文件路径的词法构建的。</p><p>在开发过程中有几个问题需要注意，一个是\0的问题，在C语言中，\0代表一个字符串的结束，因此，在做词法分析或者其他字符串操作过程中，需要重新封装字符串，重写一些字符串的处理函数，否则攻击者可能通过\0截断字符串，绕过RASP的安全检查。</p><p>另一个问题是有限状态自动机的DoS问题。在一些非确定有限状态机中，如果这个自动机不接受某个输入，那么需要否定所有的可能性，而这个过程的复杂度可能是2^n。比较常见的例子是正则表达式DoS。在这里不做深入展开，有兴趣的朋友可以多了解一下。</p><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>在做完这个RASP之后，我们回头来看看，一些问题值得我们思考和讨论。</p><p>RASP有哪些优点呢？作为纵深防御中的一层，它加深了纵深防御的维度，在Web请求发生时，从HTTP Server、Web解释器/编译器到数据库，甚至是操作系统，每一层都有自己的职责，每一层也都是防护攻击的阵地，每一层也都有对应的安全产品，每一层的防护侧重点也都不同。</p><p>RASP还有一些比较明显的优点，一是对规则依赖很低，如果使用词法分析做安全检测的话基本不需要维护规则。二是减少了HTTP Server这层攻击面，绕过比较困难，绝大多数基于HTTP Server特性的绕过对RASP无效。例如HPP、HPF、畸形HTTP请求、各种编码、拆分关键字降低评分等。三是误报率比较低。从比较理想的角度来说，如果我的后端代码写得非常安全，WAF看到一个包含攻击payload的请求就拦截，这也属于误报吧。</p><p>RASP的缺点也很明显，一是部署问题，需要在每个服务器上部署。二是无法像云WAF这样，可以通过机器学习进化检验规则。三是对服务器性能有影响，但是影响不大。根据我们对PHP RASP做的性能测试结果来看，一般来说，处理一个HTTP请求所消耗的性能中，PHP RASP消耗的占3%左右。</p><p>其实，跳出RASP，动态污点跟踪和hook这套技术方案在能做的事情很多，比如性能监控、自动化Fuzz、入侵检测系统、Webshell识别等等。如果各位有什么想法，欢迎和我们交流。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>鸟哥taint <a href="https://github.com/laruence/taint" target="_blank" rel="noopener">https://github.com/laruence/taint</a></li><li>Thinking In PHP Internals</li><li><a href="http://php.net" target="_blank" rel="noopener">http://php.net</a></li><li>PHP Complier Internals</li><li>自动机理论、语言和计算导论</li></ul><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p>两位作者水平有限，如文章有错误疏漏，或者有任何想讨论交流的，请随时联系</p><ul><li>c0d3p1ut0s <code>c0d3p1ut0s@gmail.com</code></li><li>s1m0n <code>simonfoxcat@gmail.com</code></li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>在PHP RASP中，我们使用了一部分taint和PHP内核的代码。两者的License都是PHP License。因此，在软件发行过程中，我们将遵守PHP License的相关限制。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇文章2017.11.10发在 &lt;a href=&quot;https://paper.seebug.org/449/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://paper.seebug.org/449/&lt;/a&gt; 。重发在博客如下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;RASP概念&quot;&gt;&lt;a href=&quot;#RASP概念&quot; class=&quot;headerlink&quot; title=&quot;RASP概念&quot;&gt;&lt;/a&gt;RASP概念&lt;/h2&gt;&lt;p&gt;RASP（Runtime Application self-protection）是一种在运行时检测攻击并且进行自我保护的一种技术。早在2012年，Gartner就开始关注RASP，惠普、WhiteHat Security等多家国外安全公司陆续推出RASP产品，时至今日，惠普企业的软件部门出售给了Micro Focus，RASP产品Application Defender随之易主。而在国内，去年知道创宇KCon大会兵器谱展示了JavaRASP，前一段时间，百度开源了OpenRASP，去年年底，360的0kee团队开始测试Skywolf，虽然没有看到源码和文档，但它的设计思路或许跟RASP类似。而商业化的RASP产品有OneAPM的OneRASP和青藤云的自适应安全产品。在国内，这两家做商业化RASP产品做得比较早。&lt;/p&gt;
&lt;p&gt;那么RASP到底是什么呢？它到底是怎样工作的呢？&lt;br&gt;
    
    </summary>
    
    
      <category term="Web安全" scheme="http://c0d3p1ut0s.github.io/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="RASP" scheme="http://c0d3p1ut0s.github.io/tags/RASP/"/>
    
      <category term="PHP" scheme="http://c0d3p1ut0s.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>About</title>
    <link href="http://c0d3p1ut0s.github.io/about/"/>
    <id>http://c0d3p1ut0s.github.io/about/</id>
    <published>2017-11-27T15:35:47.000Z</published>
    <updated>2018-03-05T11:30:16.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关于本人"><a href="#关于本人" class="headerlink" title="关于本人"></a>关于本人</h4><ul><li>开发者 做一些安全</li></ul><h4 id="一些微小的工作"><a href="#一些微小的工作" class="headerlink" title="一些微小的工作"></a>一些微小的工作</h4><ul><li>一类PHP RASP实现 <a href="https://paper.seebug.org/449/" target="_blank" rel="noopener">https://paper.seebug.org/449/</a></li><li>Java RASP浅析——以百度OpenRASP为例 <a href="https://paper.seebug.org/513/" target="_blank" rel="noopener">https://paper.seebug.org/513/</a></li></ul><h4 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h4><ul><li>Email: <code>YzBkM3AxdXQwc0BnbWFpbC5jb20=</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;关于本人&quot;&gt;&lt;a href=&quot;#关于本人&quot; class=&quot;headerlink&quot; title=&quot;关于本人&quot;&gt;&lt;/a&gt;关于本人&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;开发者 做一些安全&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;一些微小的工作&quot;&gt;&lt;a href=&quot;#一些微小的工作&quot;
      
    
    </summary>
    
    
      <category term="aboutme" scheme="http://c0d3p1ut0s.github.io/tags/aboutme/"/>
    
  </entry>
  
</feed>
